From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: DenaryDev <denaryplanet@gmail.com>
Date: Fri, 3 Dec 2021 22:25:10 +0500
Subject: [PATCH] Add modified version of Item-NBT-API


diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTBlock.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..138b6ed93caa4215de3adcb67e3cfc94ad52e997
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTBlock.java
@@ -0,0 +1,18 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import org.bukkit.block.Block;
+
+public class NBTBlock {
+
+	private final Block block;
+	private final NBTChunk nbtChunk;
+
+	public NBTBlock(Block block) {
+		this.block = block;
+		nbtChunk = new NBTChunk(block.getChunk());
+	}
+
+	public NBTCompound getData() {
+		return nbtChunk.getPersistentDataContainer().getOrCreateCompound("blocks").getOrCreateCompound(block.getX() + "_" + block.getY() + "_" + block.getZ());
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTChunk.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTChunk.java
new file mode 100644
index 0000000000000000000000000000000000000000..67728f555773e90c216085009252754057efb7b4
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTChunk.java
@@ -0,0 +1,21 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import org.bukkit.Chunk;
+
+public class NBTChunk {
+
+	private final Chunk chunk;
+
+	public NBTChunk(Chunk chunk) {
+		this.chunk = chunk;
+	}
+
+	/**
+	 * Gets the NBTCompound used by spigots PersistentDataAPI.
+	 * 
+	 * @return NBTCompound containing the data of the PersistentDataAPI
+	 */
+	public NBTCompound getPersistentDataContainer() {
+		return new NBTPersistentDataContainer(chunk.getPersistentDataContainer());
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTCompound.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTCompound.java
new file mode 100644
index 0000000000000000000000000000000000000000..23657ee396a6d572b9f09d3121728a53d7d6122c
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTCompound.java
@@ -0,0 +1,656 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import java.io.OutputStream;
+import java.util.Arrays;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+import org.bukkit.inventory.ItemStack;
+
+/**
+ * Base class representing NMS Compounds. For a standalone implementation check
+ * {@link NBTContainer}
+ *
+ * @author tr7zw
+ */
+public class NBTCompound {
+
+	private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
+	private final Lock readLock = readWriteLock.readLock();
+	private final Lock writeLock = readWriteLock.writeLock();
+
+	private final String compundName;
+	private final NBTCompound parent;
+
+	protected NBTCompound(NBTCompound owner, String name) {
+		this.compundName = name;
+		this.parent = owner;
+	}
+
+	protected Lock getReadLock() {
+		return readLock;
+	}
+
+	protected Lock getWriteLock() {
+		return writeLock;
+	}
+
+	protected void saveCompound() {
+		if (parent != null)
+			parent.saveCompound();
+	}
+
+	/**
+	 * @return The Compound name
+	 */
+	public String getName() {
+		return compundName;
+	}
+
+	/**
+	 * @return The NMS Compound behind this Object
+	 */
+	public Object getCompound() {
+		return parent.getCompound();
+	}
+
+	protected void setCompound(Object compound) {
+		parent.setCompound(compound);
+	}
+
+	/**
+	 * @return The parent Compound
+	 */
+	public NBTCompound getParent() {
+		return parent;
+	}
+
+	/**
+	 * Merges all data from comp into this compound. This is done in one action, so
+	 * it also works with Tiles/Entities
+	 */
+	public void mergeCompound(NBTCompound comp) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.mergeOtherNBTCompound(this, comp);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	public void setString(String key, String value) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.setData(this, ReflectionMethod.COMPOUND_SET_STRING, key, value);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	public String getString(String key) {
+		try {
+			readLock.lock();
+			return (String) NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_GET_STRING, key);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	protected String getContent(String key) {
+		return NBTReflectionUtil.getContent(this, key);
+	}
+
+	public void setInteger(String key, Integer value) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.setData(this, ReflectionMethod.COMPOUND_SET_INT, key, value);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	public Integer getInteger(String key) {
+		try {
+			readLock.lock();
+			return (Integer) NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_GET_INT, key);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public void setDouble(String key, Double value) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.setData(this, ReflectionMethod.COMPOUND_SET_DOUBLE, key, value);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	public Double getDouble(String key) {
+		try {
+			readLock.lock();
+			return (Double) NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_GET_DOUBLE, key);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public void setByte(String key, Byte value) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.setData(this, ReflectionMethod.COMPOUND_SET_BYTE, key, value);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	public Byte getByte(String key) {
+		try {
+			readLock.lock();
+			return (Byte) NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_GET_BYTE, key);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public void setShort(String key, Short value) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.setData(this, ReflectionMethod.COMPOUND_SET_SHORT, key, value);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	public Short getShort(String key) {
+		try {
+			readLock.lock();
+			return (Short) NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_GET_SHORT, key);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public void setLong(String key, Long value) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.setData(this, ReflectionMethod.COMPOUND_SET_LONG, key, value);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	public Long getLong(String key) {
+		try {
+			readLock.lock();
+			return (Long) NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_GET_LONG, key);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public void setFloat(String key, Float value) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.setData(this, ReflectionMethod.COMPOUND_SET_FLOAT, key, value);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	public Float getFloat(String key) {
+		try {
+			readLock.lock();
+			return (Float) NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_GET_FLOAT, key);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public void setByteArray(String key, byte[] value) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.setData(this, ReflectionMethod.COMPOUND_SET_BYTEARRAY, key, value);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	public byte[] getByteArray(String key) {
+		try {
+			readLock.lock();
+			return (byte[]) NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_GET_BYTEARRAY, key);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public void setIntArray(String key, int[] value) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.setData(this, ReflectionMethod.COMPOUND_SET_INTARRAY, key, value);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	public int[] getIntArray(String key) {
+		try {
+			readLock.lock();
+			return (int[]) NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_GET_INTARRAY, key);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public void setBoolean(String key, Boolean value) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.setData(this, ReflectionMethod.COMPOUND_SET_BOOLEAN, key, value);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	protected void set(String key, Object val) {
+		NBTReflectionUtil.set(this, key, val);
+		saveCompound();
+	}
+
+	public Boolean getBoolean(String key) {
+		try {
+			readLock.lock();
+			return (Boolean) NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_GET_BOOLEAN, key);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public void setObject(String key, Object value) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.setObject(this, key, value);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	/**
+	 * Uses Gson to retrieve a stored Object
+	 *
+	 * @param type Class of the Object
+	 * @return The created Object or null if empty
+	 */
+	public <T> T getObject(String key, Class<T> type) {
+		try {
+			readLock.lock();
+			return NBTReflectionUtil.getObject(this, key, type);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	/**
+	 * Save an ItemStack as a compound under a given key
+	 */
+	public void setItemStack(String key, ItemStack item) {
+		try {
+			writeLock.lock();
+			removeKey(key);
+			addCompound(key).mergeCompound(NBTItem.convertItemtoNBT(item));
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	/**
+	 * Get an ItemStack that was saved at the given key
+	 */
+	public ItemStack getItemStack(String key) {
+		try {
+			readLock.lock();
+			NBTCompound comp = getCompound(key);
+			return NBTItem.convertNBTtoItem(comp);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public void setUUID(String key, UUID value) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.setData(this, ReflectionMethod.COMPOUND_SET_UUID, key, value);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	public UUID getUUID(String key) {
+		try {
+			readLock.lock();
+			return (UUID) NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_GET_UUID, key);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public Boolean hasKey(String key) {
+		try {
+			readLock.lock();
+			Boolean b = (Boolean) NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_HAS_KEY, key);
+			if (b == null)
+				return false;
+			return b;
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public void removeKey(String key) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.remove(this, key);
+			saveCompound();
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	/**
+	 * @return Set of all stored Keys
+	 */
+	public Set<String> getKeys() {
+		try {
+			readLock.lock();
+			return NBTReflectionUtil.getKeys(this);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	/**
+	 * Creates a subCompound, or returns it if already provided
+	 *
+	 * @param name Key to use
+	 * @return The subCompound Object
+	 */
+	public NBTCompound addCompound(String name) {
+		try {
+			writeLock.lock();
+			if (getType(name) == NBTType.NBTTagCompound)
+				return getCompound(name);
+			NBTReflectionUtil.addNBTTagCompound(this, name);
+			NBTCompound comp = getCompound(name);
+			if (comp == null)
+				throw new NBTException("Error while adding Compound, got null!");
+			saveCompound();
+			return comp;
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	/**
+	 * @return The Compound instance or null
+	 */
+	public NBTCompound getCompound(String name) {
+		try {
+			readLock.lock();
+			if (getType(name) != NBTType.NBTTagCompound)
+				return null;
+			NBTCompound next = new NBTCompound(this, name);
+			if (NBTReflectionUtil.valideCompound(next))
+				return next;
+			return null;
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	/**
+	 * The same as addCompound, just with a name that better reflects what it does
+	 */
+	public NBTCompound getOrCreateCompound(String name) {
+		return addCompound(name);
+	}
+
+    /**
+     * @return The retrieved Integer List
+     */
+    public NBTList<int[]> getIntArrayList(String name) {
+        try {
+            writeLock.lock();
+            NBTList<int[]> list = NBTReflectionUtil.getList(this, name, NBTType.NBTTagIntArray, int[].class);
+            saveCompound();
+            return list;
+        } finally {
+            writeLock.unlock();
+        }
+    }
+
+    /**
+     * @return The retrieved Integer List
+     */
+    public NBTList<UUID> getUUIDList(String name) {
+        try {
+            writeLock.lock();
+            NBTList<UUID> list = NBTReflectionUtil.getList(this, name, NBTType.NBTTagIntArray, UUID.class);
+            saveCompound();
+            return list;
+        } finally {
+            writeLock.unlock();
+        }
+    }
+
+	/**
+	 * @return The retrieved String List
+	 */
+	public NBTList<String> getStringList(String name) {
+		try {
+			writeLock.lock();
+			NBTList<String> list = NBTReflectionUtil.getList(this, name, NBTType.NBTTagString, String.class);
+			saveCompound();
+			return list;
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	/**
+	 * @return The retrieved Integer List
+	 */
+	public NBTList<Integer> getIntegerList(String name) {
+		try {
+			writeLock.lock();
+			NBTList<Integer> list = NBTReflectionUtil.getList(this, name, NBTType.NBTTagInt, Integer.class);
+			saveCompound();
+			return list;
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	/**
+	 * @return The retrieved Float List
+	 */
+	public NBTList<Float> getFloatList(String name) {
+		try {
+			writeLock.lock();
+			NBTList<Float> list = NBTReflectionUtil.getList(this, name, NBTType.NBTTagFloat, Float.class);
+			saveCompound();
+			return list;
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	/**
+	 * @return The retrieved Double List
+	 */
+	public NBTList<Double> getDoubleList(String name) {
+		try {
+			writeLock.lock();
+			NBTList<Double> list = NBTReflectionUtil.getList(this, name, NBTType.NBTTagDouble, Double.class);
+			saveCompound();
+			return list;
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	/**
+	 * @return The retrieved Long List
+	 */
+	public NBTList<Long> getLongList(String name) {
+		try {
+			writeLock.lock();
+			NBTList<Long> list = NBTReflectionUtil.getList(this, name, NBTType.NBTTagLong, Long.class);
+			saveCompound();
+			return list;
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	/**
+	 * Returns the type of the list, null if not a list
+	 */
+	public NBTType getListType(String name) {
+		try {
+			readLock.lock();
+			if (getType(name) != NBTType.NBTTagList)
+				return null;
+			return NBTReflectionUtil.getListType(this, name);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	/**
+	 * @return The retrieved Compound List
+	 */
+	public NBTCompoundList getCompoundList(String name) {
+		try {
+			writeLock.lock();
+			NBTCompoundList list = (NBTCompoundList) NBTReflectionUtil.getList(this, name, NBTType.NBTTagCompound,
+					NBTListCompound.class);
+			saveCompound();
+			return list;
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+	/**
+	 * @return The type of the given stored key or null
+	 */
+	public NBTType getType(String name) {
+		try {
+			readLock.lock();
+			Object o = NBTReflectionUtil.getData(this, ReflectionMethod.COMPOUND_GET_TYPE, name);
+			if (o == null)
+				return null;
+			return NBTType.valueOf((byte) o);
+		} finally {
+			readLock.unlock();
+		}
+	}
+
+	public void writeCompound(OutputStream stream) {
+		try {
+			writeLock.lock();
+			NBTReflectionUtil.writeApiNBT(this, stream);
+		} finally {
+			writeLock.unlock();
+		}
+	}
+
+    /**
+     * @return A {@link String} representation of the NBT in Mojang JSON. This is different from normal JSON!
+     */
+	@Override
+	public String toString() {
+        try {
+            readLock.lock();
+            Object comp = NBTReflectionUtil.getToCompount(getCompound(), this);
+            if (comp == null)
+                return "{}";
+            return comp.toString();
+        } finally {
+            readLock.unlock();
+        }
+	}
+
+    /**
+     * Remove all keys from this compound
+     */
+    public void clearNBT() {
+        for (String key : getKeys()) {
+            removeKey(key);
+        }
+    }
+
+	@Override
+	public int hashCode() {
+		return toString().hashCode();
+	}
+
+	/**
+	 * Does a deep compare to check if everything is the same
+	 */
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (obj instanceof NBTCompound other) {
+			if (getKeys().equals(other.getKeys())) {
+				for (String key : getKeys()) {
+					if (!isEqual(this, other, key)) {
+						return false;
+					}
+				}
+				return true;
+			}
+		}
+		return false;
+	}
+
+	protected static boolean isEqual(NBTCompound compA, NBTCompound compB, String key) {
+		if (compA.getType(key) != compB.getType(key)) return false;
+		return switch (compA.getType(key)) {
+			case NBTTagByte -> compA.getByte(key).equals(compB.getByte(key));
+			case NBTTagByteArray -> Arrays.equals(compA.getByteArray(key), compB.getByteArray(key));
+			case NBTTagCompound -> compA.getCompound(key).equals(compB.getCompound(key));
+			case NBTTagDouble -> compA.getDouble(key).equals(compB.getDouble(key));
+			case NBTTagEnd -> true; //??
+			case NBTTagFloat -> compA.getFloat(key).equals(compB.getFloat(key));
+			case NBTTagInt -> compA.getInteger(key).equals(compB.getInteger(key));
+			case NBTTagIntArray -> Arrays.equals(compA.getIntArray(key), compB.getIntArray(key));
+			case NBTTagList -> NBTReflectionUtil.getEntry(compA, key).toString().equals(NBTReflectionUtil.getEntry(compB, key).toString()); // Just string compare the 2 lists
+			case NBTTagLong -> compA.getLong(key).equals(compB.getLong(key));
+			case NBTTagShort -> compA.getShort(key).equals(compB.getShort(key));
+			case NBTTagString -> compA.getString(key).equals(compB.getString(key));
+		};
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTCompoundList.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTCompoundList.java
new file mode 100644
index 0000000000000000000000000000000000000000..84dd6210ab468780b70d62e07eaaa866b5e62fe5
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTCompoundList.java
@@ -0,0 +1,91 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ClassWrapper;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+
+/**
+ * {@link NBTListCompound} implementation for NBTLists.
+ *
+ * @author tr7zw
+ */
+public class NBTCompoundList extends NBTList<NBTListCompound> {
+
+	protected NBTCompoundList(NBTCompound owner, String name, NBTType type, Object list) {
+		super(owner, name, type, list);
+	}
+
+	/**
+	 * Adds a new Compound to the end of the List and returns it.
+	 * 
+	 * @return The added {@link NBTListCompound}
+	 */
+	public NBTListCompound addCompound() {
+		return (NBTListCompound) addCompound(null);
+	}
+
+	/**
+	 * Adds a copy of the Compound to the end of the List and returns it.
+	 * When null is given, a new Compound will be created
+	 */
+	public NBTCompound addCompound(NBTCompound comp) {
+		try {
+			Object compound = ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz().newInstance();
+			ReflectionMethod.LIST_ADD.run(listObject, size(), compound);
+			getParent().saveCompound();
+			NBTListCompound listcomp = new NBTListCompound(this, compound);
+			if (comp != null){
+				listcomp.mergeCompound(comp);
+			}
+			return listcomp;
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		}
+	}
+
+	/**
+	 * Adds a new Compound to the end of the List.
+	 *
+	 * @deprecated Please use addCompound!
+	 * @return True, if compound was added
+	 */
+	@Override
+	@Deprecated
+	public boolean add(NBTListCompound empty) {
+		return addCompound(empty) != null;
+	}
+
+	@Override
+	public void add(int index, NBTListCompound element) {
+		if (element != null) {
+			throw new NBTException("You need to pass null! ListCompounds from other lists won't work.");
+		}
+		try {
+			Object compound = ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz().newInstance();
+			ReflectionMethod.LIST_ADD.run(listObject, index, compound);
+			super.getParent().saveCompound();
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		}
+	}
+
+	@Override
+	public NBTListCompound get(int index) {
+		try {
+			Object compound = ReflectionMethod.LIST_GET_COMPOUND.run(listObject, index);
+			return new NBTListCompound(this, compound);
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		}
+	}
+
+	@Override
+	public NBTListCompound set(int index, NBTListCompound element) {
+		throw new NBTException("This method doesn't work in the ListCompound context.");
+	}
+
+	@Override
+	protected Object asTag(NBTListCompound object) {
+		return null;
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTContainer.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTContainer.java
new file mode 100644
index 0000000000000000000000000000000000000000..896d2df5602390b138113259359b7010fc567542
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTContainer.java
@@ -0,0 +1,76 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import java.io.InputStream;
+
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ClassWrapper;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ObjectCreator;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+
+/**
+ * A Standalone {@link NBTCompound} implementation. All data is just kept inside
+ * this Object.
+ *
+ * @author tr7zw
+ */
+public class NBTContainer extends NBTCompound {
+
+	private Object nbt;
+
+	/**
+	 * Creates an empty, standalone NBTCompound
+	 */
+	public NBTContainer() {
+		super(null, null);
+		nbt = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+	}
+
+	/**
+	 * Takes in any NMS Compound to wrap it
+	 */
+	public NBTContainer(Object nbt) {
+		super(null, null);
+		if (nbt == null) {
+			throw new NullPointerException("The NBT-Object can't be null!");
+		}
+		if (!ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz().isAssignableFrom(nbt.getClass())) {
+			throw new NBTException("The object '" + nbt.getClass() + "' is not a valid NBT-Object!");
+		}
+		this.nbt = nbt;
+	}
+
+	/**
+	 * Reads in a NBT InputStream
+	 */
+	public NBTContainer(InputStream inputsteam) {
+		super(null, null);
+		this.nbt = NBTReflectionUtil.readNBT(inputsteam);
+	}
+
+	/**
+	 * Parses in a NBT String to a standalone {@link NBTCompound}. Can throw a
+	 * {@link NBTException} in case something goes wrong.
+	 */
+	public NBTContainer(String nbtString) {
+		super(null, null);
+		if (nbtString == null) {
+			throw new NullPointerException("The String can't be null!");
+		}
+		try {
+			nbt = ReflectionMethod.PARSE_NBT.run(null, nbtString);
+		} catch (Exception ex) {
+			throw new NBTException("Unable to parse Malformed Json!", ex);
+		}
+	}
+
+	@Override
+	public Object getCompound() {
+		return nbt;
+	}
+
+	@Override
+	public void setCompound(Object tag) {
+		nbt = tag;
+	}
+
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTDoubleList.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTDoubleList.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ca21ec07d241740a2abc0c07003f3ba9db2cf02
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTDoubleList.java
@@ -0,0 +1,44 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ClassWrapper;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+
+/**
+ * Double implementation for NBTLists.
+ *
+ * @author tr7zw
+ */
+public class NBTDoubleList extends NBTList<Double> {
+
+	protected NBTDoubleList(NBTCompound owner, String name, NBTType type, Object list) {
+		super(owner, name, type, list);
+	}
+
+	@Override
+	protected Object asTag(Double object) {
+		try {
+			Constructor<?> con = ClassWrapper.NMS_NBTTAGDOUBLE.getClazz().getDeclaredConstructor(double.class);
+			con.setAccessible(true);
+			return con.newInstance(object);
+		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
+				| NoSuchMethodException | SecurityException e) {
+			throw new NBTException("Error while wrapping the Object " + object + " to it's NMS object!", e);
+		}
+	}
+
+	@Override
+	public Double get(int index) {
+		try {
+			Object obj = ReflectionMethod.LIST_GET.run(listObject, index);
+			return Double.valueOf(obj.toString());
+		} catch (NumberFormatException nf) {
+			return 0d;
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		}
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTEntity.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1332b8117e5d804213fc2bbf465410f3e22730d
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTEntity.java
@@ -0,0 +1,53 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Entity;
+
+/**
+ * NBT class to access vanilla tags from Entities. Entities don't support custom
+ * tags. Use the NBTInjector for custom tags. Changes will be instantly applied
+ * to the Entity, use the merge method to do many things at once.
+ *
+ * @author tr7zw
+ */
+public class NBTEntity extends NBTCompound {
+
+	private final Entity ent;
+
+	/**
+	 * @param entity Any valid Bukkit Entity
+	 */
+	public NBTEntity(Entity entity) {
+		super(null, null);
+		if (entity == null) {
+			throw new NullPointerException("Entity can't be null!");
+		}
+		ent = entity;
+	}
+
+	@Override
+	public Object getCompound() {
+        if (!Bukkit.isPrimaryThread()) {
+            throw new NBTException("Entity NBT needs to be accessed sync!");
+        }
+		return NBTReflectionUtil.getEntityNBTTagCompound(NBTReflectionUtil.getNMSEntity(ent));
+	}
+
+	@Override
+	protected void setCompound(Object compound) {
+        if (!Bukkit.isPrimaryThread()) {
+            throw new NBTException("Entity NBT needs to be accessed sync!");
+        }
+		NBTReflectionUtil.setEntityNBTTag(compound, NBTReflectionUtil.getNMSEntity(ent));
+	}
+
+	/**
+	 * Gets the NBTCompound used by spigots PersistentDataAPI.
+	 * 
+	 * @return NBTCompound containing the data of the PersistentDataAPI
+	 */
+	public NBTCompound getPersistentDataContainer() {
+		return new NBTPersistentDataContainer(ent.getPersistentDataContainer());
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTFile.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTFile.java
new file mode 100644
index 0000000000000000000000000000000000000000..67bbba0eb3102064b14245a334ec48ae4665ac93
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTFile.java
@@ -0,0 +1,73 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ObjectCreator;
+
+/**
+ * {@link NBTCompound} implementation backed by a {@link File}
+ *
+ * @author tr7zw
+ */
+public class NBTFile extends NBTCompound {
+
+	private final File file;
+	private Object nbt;
+
+	/**
+	 * Creates a NBTFile that uses @param file to store it's data. If this file
+	 * exists, the data will be loaded.
+	 */
+	public NBTFile(File file) throws IOException {
+		super(null, null);
+		if (file == null) {
+			throw new NullPointerException("File can't be null!");
+		}
+		this.file = file;
+		if (file.exists()) {
+			FileInputStream inputsteam = new FileInputStream(file);
+			nbt = NBTReflectionUtil.readNBT(inputsteam);
+		} else {
+			nbt = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+			save();
+		}
+	}
+
+	/**
+	 * Saves the data to the file
+	 */
+	public void save() throws IOException {
+		try {
+			getWriteLock().lock();
+			if (!file.exists()) {
+				file.getParentFile().mkdirs();
+				if (!file.createNewFile())
+					throw new IOException("Unable to create file at " + file.getAbsolutePath());
+			}
+			FileOutputStream outStream = new FileOutputStream(file);
+			NBTReflectionUtil.writeNBT(nbt, outStream);
+		} finally {
+			getWriteLock().unlock();
+		}
+	}
+
+	/**
+	 * @return The File used to store the data
+	 */
+	public File getFile() {
+		return file;
+	}
+
+	@Override
+	public Object getCompound() {
+		return nbt;
+	}
+
+	@Override
+	protected void setCompound(Object compound) {
+		nbt = compound;
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTFloatList.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTFloatList.java
new file mode 100644
index 0000000000000000000000000000000000000000..ec7d4d84d9de03d9184b9a1ba36a6a3615c9af55
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTFloatList.java
@@ -0,0 +1,44 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ClassWrapper;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+
+/**
+ * Float implementation for NBTLists
+ *
+ * @author tr7zw
+ */
+public class NBTFloatList extends NBTList<Float> {
+
+	protected NBTFloatList(NBTCompound owner, String name, NBTType type, Object list) {
+		super(owner, name, type, list);
+	}
+
+	@Override
+	protected Object asTag(Float object) {
+		try {
+			Constructor<?> con = ClassWrapper.NMS_NBTTAGFLOAT.getClazz().getDeclaredConstructor(float.class);
+			con.setAccessible(true);
+			return con.newInstance(object);
+		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
+				| NoSuchMethodException | SecurityException e) {
+			throw new NBTException("Error while wrapping the Object " + object + " to it's NMS object!", e);
+		}
+	}
+
+	@Override
+	public Float get(int index) {
+		try {
+			Object obj = ReflectionMethod.LIST_GET.run(listObject, index);
+			return Float.valueOf(obj.toString());
+		} catch (NumberFormatException nf) {
+			return 0f;
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		}
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTGameProfile.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTGameProfile.java
new file mode 100644
index 0000000000000000000000000000000000000000..19fe39e17cd41a2a25cfd1bbe68b343a135a8aba
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTGameProfile.java
@@ -0,0 +1,29 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import com.mojang.authlib.GameProfile;
+
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ObjectCreator;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+
+public class NBTGameProfile {
+
+	/**
+	 * Convert a GameProfile to NBT. The NBT then can be modified or be stored
+	 * 
+	 * @param profile profile to convert
+	 * @return A NBTContainer with all the GameProfile data
+	 */
+	public static NBTCompound toNBT(GameProfile profile) {
+		return new NBTContainer(ReflectionMethod.GAMEPROFILE_SERIALIZE.run(null, ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance(), profile));
+	}
+
+	/**
+	 * Reconstructs a GameProfile from a NBTCompound
+	 * 
+	 * @param compound Has to contain GameProfile data
+	 * @return The reconstructed GameProfile
+	 */
+	public static GameProfile fromNBT(NBTCompound compound) {
+		return (GameProfile) ReflectionMethod.GAMEPROFILE_DESERIALIZE.run(null, NBTReflectionUtil.getToCompount(compound.getCompound(), compound));
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTIntArrayList.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTIntArrayList.java
new file mode 100644
index 0000000000000000000000000000000000000000..1990ebacf1fbca57ebe3ee93f8de758b78c69777
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTIntArrayList.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ClassWrapper;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
+/**
+ * Integer array implementation for NBTLists
+ *
+ * @author tr7zw
+ */
+public class NBTIntArrayList extends NBTList<int[]> {
+
+    private final NBTContainer tmpContainer;
+
+    protected NBTIntArrayList(NBTCompound owner, String name, NBTType type, Object list) {
+        super(owner, name, type, list);
+        this.tmpContainer = new NBTContainer();
+    }
+
+    @Override
+    protected Object asTag(int[] object) {
+        try {
+            Constructor<?> con = ClassWrapper.NMS_NBTTAGINTARRAY.getClazz().getDeclaredConstructor(int[].class);
+            con.setAccessible(true);
+            return con.newInstance(object);
+        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
+            | NoSuchMethodException | SecurityException e) {
+            throw new NBTException("Error while wrapping the Object " + object + " to it's NMS object!", e);
+        }
+    }
+
+    @Override
+    public int[] get(int index) {
+        try {
+            Object obj = ReflectionMethod.LIST_GET.run(listObject, index);
+            ReflectionMethod.COMPOUND_SET.run(tmpContainer.getCompound(), "tmp", obj);
+            int[] val = tmpContainer.getIntArray("tmp");
+            tmpContainer.removeKey("tmp");
+            return val;
+        } catch (NumberFormatException nf) {
+            return null;
+        } catch (Exception ex) {
+            throw new NBTException(ex);
+        }
+    }
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTIntegerList.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTIntegerList.java
new file mode 100644
index 0000000000000000000000000000000000000000..ebe4d37e153cd38691483a1a36c07e60bec21cf9
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTIntegerList.java
@@ -0,0 +1,44 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ClassWrapper;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+
+/**
+ * Integer implementation for NBTLists
+ *
+ * @author tr7zw
+ */
+public class NBTIntegerList extends NBTList<Integer> {
+
+	protected NBTIntegerList(NBTCompound owner, String name, NBTType type, Object list) {
+		super(owner, name, type, list);
+	}
+
+	@Override
+	protected Object asTag(Integer object) {
+		try {
+			Constructor<?> con = ClassWrapper.NMS_NBTTAGINT.getClazz().getDeclaredConstructor(int.class);
+			con.setAccessible(true);
+			return con.newInstance(object);
+		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
+				| NoSuchMethodException | SecurityException e) {
+			throw new NBTException("Error while wrapping the Object " + object + " to it's NMS object!", e);
+		}
+	}
+
+	@Override
+	public Integer get(int index) {
+		try {
+			Object obj = ReflectionMethod.LIST_GET.run(listObject, index);
+			return Integer.valueOf(obj.toString());
+		} catch (NumberFormatException nf) {
+			return 0;
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		}
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTItem.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..0c56860177795d40f04d2f92fe00948155d5e938
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTItem.java
@@ -0,0 +1,165 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+import org.bukkit.Material;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.ItemMeta;
+
+/**
+ * NBT class to access vanilla/custom tags on ItemStacks. This class doesn't
+ * autosave to the Itemstack, use getItem to get the changed ItemStack
+ *
+ * @author tr7zw
+ */
+public class NBTItem extends NBTCompound {
+
+	private final boolean directApply;
+	private ItemStack bukkitItem;
+	private ItemStack originalSrcStack = null;
+
+	/**
+	 * Constructor for NBTItems. The ItemStack will be cloned!
+	 */
+	public NBTItem(ItemStack item) {
+		this(item, false);
+	}
+
+	/**
+	 * Constructor for NBTItems. The ItemStack will be cloned! If directApply is true,
+	 * all changed will be mapped to the original item. Changes to the NBTItem will overwrite changes done
+	 * to the original item in that case.
+	 */
+	public NBTItem(ItemStack item, boolean directApply) {
+		super(null, null);
+		if (item == null || item.getType() == Material.AIR) {
+			throw new NullPointerException("ItemStack can't be null/Air! This is not a NBTAPI bug!");
+		}
+		this.directApply = directApply;
+		bukkitItem = item.clone();
+		if(directApply) {
+			this.originalSrcStack = item;
+		}
+	}
+
+	@Override
+	public Object getCompound() {
+		return NBTReflectionUtil.getItemRootNBTTagCompound(ReflectionMethod.ITEMSTACK_NMSCOPY.run(null, bukkitItem));
+	}
+
+	@Override
+	protected void setCompound(Object compound) {
+		Object stack = ReflectionMethod.ITEMSTACK_NMSCOPY.run(null, bukkitItem);
+		ReflectionMethod.ITEMSTACK_SET_TAG.run(stack, compound);
+		bukkitItem = (ItemStack) ReflectionMethod.ITEMSTACK_BUKKITMIRROR.run(null, stack);
+	}
+
+	/**
+	 * Apply stored NBT tags to the provided ItemStack.
+	 * <p>
+	 * Note: This will completely override current item's {@link ItemMeta}.
+	 * If you still want to keep the original item's NBT tags, see
+	 * {@link #mergeNBT(ItemStack)} and {@link #mergeCustomNBT(ItemStack)}.
+	 *
+	 * @param item ItemStack that should get the new NBT data
+	 */
+	public void applyNBT(ItemStack item) {
+		if (item == null || item.getType() == Material.AIR) {
+			throw new NullPointerException("ItemStack can't be null/Air! This is not a NBTAPI bug!");
+		}
+		NBTItem nbti = new NBTItem(new ItemStack(item.getType()));
+		nbti.mergeCompound(this);
+		item.setItemMeta(nbti.getItem().getItemMeta());
+	}
+
+	/**
+	 * Merge all NBT tags to the provided ItemStack.
+	 *
+	 * @param item ItemStack that should get the new NBT data
+	 */
+	public void mergeNBT(ItemStack item) {
+		NBTItem nbti = new NBTItem(item);
+		nbti.mergeCompound(this);
+		item.setItemMeta(nbti.getItem().getItemMeta());
+	}
+
+	/**
+	 * Merge only custom (non-vanilla) NBT tags to the provided ItemStack.
+	 *
+	 * @param item ItemStack that should get the new NBT data
+	 */
+	public void mergeCustomNBT(ItemStack item) {
+		if (item == null || item.getType() == Material.AIR) {
+			throw new NullPointerException("ItemStack can't be null/Air!");
+		}
+		ItemMeta meta = item.getItemMeta();
+		NBTReflectionUtil.getUnhandledNBTTags(meta).putAll(NBTReflectionUtil.getUnhandledNBTTags(bukkitItem.getItemMeta()));
+		item.setItemMeta(meta);
+	}
+
+	/**
+	 * True, if the item has any tags now known for this item type.
+	 * 
+	 * @return true when custom tags are present
+	 */
+	public boolean hasCustomNbtData() {
+        ItemMeta meta = bukkitItem.getItemMeta();
+        return !NBTReflectionUtil.getUnhandledNBTTags(meta).isEmpty();
+	}
+
+	/**
+	 * Remove all custom (non-vanilla) NBT tags from the NBTItem.
+	 */
+	public void clearCustomNBT() {
+		ItemMeta meta = bukkitItem.getItemMeta();
+		NBTReflectionUtil.getUnhandledNBTTags(meta).clear();
+		bukkitItem.setItemMeta(meta);
+	}
+
+	/**
+	 * @return The modified ItemStack
+	 */
+	public ItemStack getItem() {
+		return bukkitItem;
+	}
+
+	protected void setItem(ItemStack item) {
+		bukkitItem = item;
+	}
+
+	/**
+	 * This may return true even when the NBT is empty.
+	 * 
+	 * @return Does the ItemStack have a NBTCompound.
+	 */
+	public boolean hasNBTData() {
+		return getCompound() != null;
+	}
+
+	/**
+	 * Helper method that converts {@link ItemStack} to {@link NBTContainer} with
+	 * all it's data like Material, Damage, Amount and Tags.
+	 *
+	 * @return Standalone {@link NBTContainer} with the Item's data
+	 */
+	public static NBTContainer convertItemtoNBT(ItemStack item) {
+		return NBTReflectionUtil.convertNMSItemToNBTCompound(ReflectionMethod.ITEMSTACK_NMSCOPY.run(null, item));
+	}
+
+	/**
+	 * Helper method to do the inverse to "convertItemtoNBT". Creates an
+	 * {@link ItemStack} using the {@link NBTCompound}
+	 *
+	 * @return ItemStack using the {@link NBTCompound}'s data
+	 */
+	public static ItemStack convertNBTtoItem(NBTCompound comp) {
+		return (ItemStack) ReflectionMethod.ITEMSTACK_BUKKITMIRROR.run(null,
+				NBTReflectionUtil.convertNBTCompoundToNMSItem(comp));
+	}
+
+	@Override
+	protected void saveCompound() {
+		if (directApply) {
+			applyNBT(originalSrcStack);
+		}
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTList.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTList.java
new file mode 100644
index 0000000000000000000000000000000000000000..157f66c05c6eac3b53f42e746d9d1fe44634ac1d
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTList.java
@@ -0,0 +1,428 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+
+import io.sapphiremc.sapphire.api.nbt.utils.MinecraftVersion;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+
+/**
+ * Abstract List implementation for ListCompounds
+ *
+ * @author tr7zw
+ */
+public abstract class NBTList<T> implements List<T> {
+
+	private final String listName;
+	private final NBTCompound parent;
+	private final NBTType type;
+	protected Object listObject;
+
+	protected NBTList(NBTCompound owner, String name, NBTType type, Object list) {
+		this.parent = owner;
+		this.listName = name;
+		this.type = type;
+		this.listObject = list;
+	}
+
+	/**
+	 * @return Name of this list-compound
+	 */
+	public String getName() {
+		return listName;
+	}
+
+	/**
+	 * @return The Compound's parent Object
+	 */
+	public NBTCompound getParent() {
+		return parent;
+	}
+
+	protected void save() {
+		parent.set(listName, listObject);
+	}
+
+	protected abstract Object asTag(T object);
+
+	@Override
+	public boolean add(T element) {
+		try {
+			parent.getWriteLock().lock();
+			if (MinecraftVersion.getVersion().getVersionId() >= MinecraftVersion.v1_14_R1.getVersionId()) {
+				ReflectionMethod.LIST_ADD.run(listObject, size(), asTag(element));
+			} else {
+				ReflectionMethod.LEGACY_LIST_ADD.run(listObject, asTag(element));
+			}
+			save();
+			return true;
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		} finally {
+			parent.getWriteLock().unlock();
+		}
+	}
+
+	@Override
+	public void add(int index, T element) {
+		try {
+			parent.getWriteLock().lock();
+			if (MinecraftVersion.getVersion().getVersionId() >= MinecraftVersion.v1_14_R1.getVersionId()) {
+				ReflectionMethod.LIST_ADD.run(listObject, index, asTag(element));
+			} else {
+				ReflectionMethod.LEGACY_LIST_ADD.run(listObject, asTag(element));
+			}
+			save();
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		} finally {
+			parent.getWriteLock().unlock();
+		}
+	}
+
+	@Override
+	public T set(int index, T element) {
+		try {
+			parent.getWriteLock().lock();
+			T prev = get(index);
+			ReflectionMethod.LIST_SET.run(listObject, index, asTag(element));
+			save();
+			return prev;
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		} finally {
+			parent.getWriteLock().unlock();
+		}
+	}
+
+	public T remove(int i) {
+		try {
+			parent.getWriteLock().lock();
+			T old = get(i);
+			ReflectionMethod.LIST_REMOVE_KEY.run(listObject, i);
+			save();
+			return old;
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		} finally {
+			parent.getWriteLock().unlock();
+		}
+	}
+
+	public int size() {
+		try {
+			parent.getReadLock().lock();
+			return (int) ReflectionMethod.LIST_SIZE.run(listObject);
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		} finally {
+			parent.getReadLock().unlock();
+		}
+	}
+
+	/**
+	 * @return The type that this list contains
+	 */
+	public NBTType getType() {
+		return type;
+	}
+
+	@Override
+	public boolean isEmpty() {
+		return size() == 0;
+	}
+
+	@Override
+	public void clear() {
+		while (!isEmpty()) {
+			remove(0);
+		}
+	}
+
+	@Override
+	public boolean contains(Object o) {
+		try {
+			parent.getReadLock().lock();
+			for (int i = 0; i < size(); i++) {
+				if (o.equals(get(i)))
+					return true;
+			}
+			return false;
+		} finally {
+			parent.getReadLock().unlock();
+		}
+	}
+
+	@Override
+	public int indexOf(Object o) {
+		try {
+			parent.getReadLock().lock();
+			for (int i = 0; i < size(); i++) {
+				if (o.equals(get(i)))
+					return i;
+			}
+			return -1;
+		} finally {
+			parent.getReadLock().unlock();
+		}
+	}
+
+	@Override
+	public boolean addAll(Collection<? extends T> c) {
+		try {
+			parent.getWriteLock().lock();
+			int size = size();
+			for (T ele : c) {
+				add(ele);
+			}
+			return size != size();
+		} finally {
+			parent.getWriteLock().unlock();
+		}
+	}
+
+	@Override
+	public boolean addAll(int index, Collection<? extends T> c) {
+		try {
+			parent.getWriteLock().lock();
+			int size = size();
+			for (T ele : c) {
+				add(index++, ele);
+			}
+			return size != size();
+		} finally {
+			parent.getWriteLock().unlock();
+		}
+	}
+
+	@Override
+	public boolean containsAll(Collection<?> c) {
+		try {
+			parent.getReadLock().lock();
+			for (Object ele : c) {
+				if (!contains(ele))
+					return false;
+			}
+			return true;
+		} finally {
+			parent.getReadLock().unlock();
+		}
+	}
+
+	@Override
+	public int lastIndexOf(Object o) {
+		try {
+			parent.getReadLock().lock();
+			int index = -1;
+			for (int i = 0; i < size(); i++) {
+				if (o.equals(get(i)))
+					index = i;
+			}
+			return index;
+		} finally {
+			parent.getReadLock().unlock();
+		}
+	}
+
+	@Override
+	public boolean removeAll(Collection<?> c) {
+		try {
+			parent.getWriteLock().lock();
+			int size = size();
+			for (Object obj : c) {
+				remove(obj);
+			}
+			return size != size();
+		} finally {
+			parent.getWriteLock().unlock();
+		}
+	}
+
+	@Override
+	public boolean retainAll(Collection<?> c) {
+		try {
+			parent.getWriteLock().lock();
+			int size = size();
+			for (Object obj : c) {
+				for (int i = 0; i < size(); i++) {
+					if (!obj.equals(get(i))) {
+						remove(i--);
+					}
+				}
+			}
+			return size != size();
+		} finally {
+			parent.getWriteLock().unlock();
+		}
+	}
+
+	@Override
+	public boolean remove(Object o) {
+		try {
+			parent.getWriteLock().lock();
+			int size = size();
+			int id = -1;
+			while ((id = indexOf(o)) != -1) {
+				remove(id);
+			}
+			return size != size();
+		} finally {
+			parent.getWriteLock().unlock();
+		}
+	}
+
+	@Override
+	public Iterator<T> iterator() {
+		return new Iterator<T>() {
+
+			private int index = -1;
+
+			@Override
+			public boolean hasNext() {
+				return size() > index + 1;
+			}
+
+			@Override
+			public T next() {
+				if (!hasNext())
+					throw new NoSuchElementException();
+				return get(++index);
+			}
+
+			@Override
+			public void remove() {
+				NBTList.this.remove(index);
+				index--;
+			}
+		};
+	}
+
+	@Override
+	public ListIterator<T> listIterator() {
+		return listIterator(0);
+	}
+
+	@Override
+	public ListIterator<T> listIterator(int startIndex) {
+		final NBTList<T> list = this;
+		return new ListIterator<T>() {
+
+			int index = startIndex - 1;
+
+			@Override
+			public void add(T e) {
+				list.add(index, e);
+			}
+
+			@Override
+			public boolean hasNext() {
+				return size() > index + 1;
+			}
+
+			@Override
+			public boolean hasPrevious() {
+				return index >= 0 && index <= size();
+			}
+
+			@Override
+			public T next() {
+				if (!hasNext())
+					throw new NoSuchElementException();
+				return get(++index);
+			}
+
+			@Override
+			public int nextIndex() {
+				return index + 1;
+			}
+
+			@Override
+			public T previous() {
+				if (!hasPrevious())
+					throw new NoSuchElementException("Id: " + (index - 1));
+				return get(index--);
+			}
+
+			@Override
+			public int previousIndex() {
+				return index - 1;
+			}
+
+			@Override
+			public void remove() {
+				list.remove(index);
+				index--;
+			}
+
+			@Override
+			public void set(T e) {
+				list.set(index, e);
+			}
+		};
+	}
+
+	@Override
+	public Object[] toArray() {
+		try {
+			parent.getReadLock().lock();
+			Object[] ar = new Object[size()];
+			for (int i = 0; i < size(); i++)
+				ar[i] = get(i);
+			return ar;
+		} finally {
+			parent.getReadLock().unlock();
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	@Override
+	public <E> E[] toArray(E[] a) {
+		try {
+			parent.getReadLock().lock();
+			E[] ar = Arrays.copyOf(a, size());
+			Arrays.fill(ar, null);
+			Class<?> arrayclass = a.getClass().getComponentType();
+			for (int i = 0; i < size(); i++) {
+				T obj = get(i);
+				if (arrayclass.isInstance(obj)) {
+					ar[i] = (E) get(i);
+				} else {
+					throw new ArrayStoreException("The array does not match the objects stored in the List.");
+				}
+			}
+			return ar;
+		} finally {
+			parent.getReadLock().unlock();
+		}
+	}
+
+	@Override
+	public List<T> subList(int fromIndex, int toIndex) {
+		try {
+			parent.getReadLock().lock();
+			ArrayList<T> list = new ArrayList<>();
+			for (int i = fromIndex; i < toIndex; i++)
+				list.add(get(i));
+			return list;
+		} finally {
+			parent.getReadLock().unlock();
+		}
+	}
+
+	@Override
+	public String toString() {
+		try {
+			parent.getReadLock().lock();
+			return listObject.toString();
+		} finally {
+			parent.getReadLock().unlock();
+		}
+	}
+
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTListCompound.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTListCompound.java
new file mode 100644
index 0000000000000000000000000000000000000000..27933f27e70ca73307b2cca1f2f1c940393101ec
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTListCompound.java
@@ -0,0 +1,40 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+/**
+ * Cut down version of the {@link NBTCompound} for inside
+ * {@link NBTCompoundList} This Compound implementation is missing the ability
+ * for further subCompounds and Lists. This class probably will change in the
+ * future
+ *
+ * @author tr7zw
+ */
+public class NBTListCompound extends NBTCompound {
+
+	private final NBTList<?> owner;
+	private Object compound;
+
+	protected NBTListCompound(NBTList<?> parent, Object obj) {
+		super(null, null);
+		owner = parent;
+		compound = obj;
+	}
+
+	public NBTList<?> getListParent() {
+		return owner;
+	}
+
+	@Override
+	public Object getCompound() {
+		return compound;
+	}
+
+	@Override
+	protected void setCompound(Object compound) {
+		this.compound = compound;
+	}
+
+	@Override
+	protected void saveCompound() {
+		owner.save();
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTLongList.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTLongList.java
new file mode 100644
index 0000000000000000000000000000000000000000..c9959c80305d8c6a6fea4ad786b332f0093950ca
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTLongList.java
@@ -0,0 +1,44 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ClassWrapper;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+
+/**
+ * Long implementation for NBTLists
+ *
+ * @author tr7zw
+ */
+public class NBTLongList extends NBTList<Long> {
+
+	protected NBTLongList(NBTCompound owner, String name, NBTType type, Object list) {
+		super(owner, name, type, list);
+	}
+
+	@Override
+	protected Object asTag(Long object) {
+		try {
+			Constructor<?> con = ClassWrapper.NMS_NBTTAGLONG.getClazz().getDeclaredConstructor(long.class);
+			con.setAccessible(true);
+			return con.newInstance(object);
+		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
+				| NoSuchMethodException | SecurityException e) {
+			throw new NBTException("Error while wrapping the Object " + object + " to it's NMS object!", e);
+		}
+	}
+
+	@Override
+	public Long get(int index) {
+		try {
+			Object obj = ReflectionMethod.LIST_GET.run(listObject, index);
+			return Long.valueOf(obj.toString().replace("L", ""));
+		} catch (NumberFormatException nf) {
+			return 0L;
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		}
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTPersistentDataContainer.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTPersistentDataContainer.java
new file mode 100644
index 0000000000000000000000000000000000000000..ad93aa8fcb7d8022db185071224a2fc937960c72
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTPersistentDataContainer.java
@@ -0,0 +1,29 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import java.util.Map;
+
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+import org.bukkit.persistence.PersistentDataContainer;
+
+public class NBTPersistentDataContainer extends NBTCompound {
+
+	private final PersistentDataContainer container;
+
+	public NBTPersistentDataContainer(PersistentDataContainer container) {
+		super(null, null);
+		this.container = container;
+	}
+
+	@Override
+	public Object getCompound() {
+		return ReflectionMethod.CRAFT_PERSISTENT_DATA_CONTAINER_TO_TAG.run(container);
+	}
+
+	@Override
+	protected void setCompound(Object compound) {
+		@SuppressWarnings("unchecked")
+		Map<Object, Object> map = (Map<Object, Object>) ReflectionMethod.CRAFT_PERSISTENT_DATA_CONTAINER_GET_MAP.run(container);
+		map.clear();
+		ReflectionMethod.CRAFT_PERSISTENT_DATA_CONTAINER_PUT_ALL.run(container, compound);
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTReflectionUtil.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTReflectionUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..7e0427dffe5e5508bd6a800a5b56b9103c286bc4
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTReflectionUtil.java
@@ -0,0 +1,548 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.Serializable;
+import java.lang.reflect.Field;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.Map;
+import java.util.Set;
+
+import io.sapphiremc.sapphire.api.nbt.utils.GsonWrapper;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ClassWrapper;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ObjectCreator;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+import java.util.UUID;
+import org.bukkit.block.BlockState;
+import org.bukkit.entity.Entity;
+import org.bukkit.inventory.meta.ItemMeta;
+
+/**
+ * Utility class for translating NBTApi calls to reflections into NMS code All
+ * methods are allowed to throw {@link NBTException}
+ *
+ * @author tr7zw
+ */
+public class NBTReflectionUtil {
+
+	private static Field field_unhandledTags = null;
+
+	static {
+		try {
+			field_unhandledTags = ClassWrapper.CRAFT_METAITEM.getClazz().getDeclaredField("unhandledTags");
+			field_unhandledTags.setAccessible(true);
+		} catch (NoSuchFieldException ignored) {
+		}
+	}
+
+	/**
+	 * Hidden constructor
+	 */
+	private NBTReflectionUtil() {
+
+	}
+
+	/**
+	 * Gets the NMS Entity for a given Bukkit Entity
+	 * 
+	 * @param entity Bukkit Entity
+	 * @return NMS Entity
+	 */
+	public static Object getNMSEntity(Entity entity) {
+		try {
+			return ReflectionMethod.CRAFT_ENTITY_GET_HANDLE.run(ClassWrapper.CRAFT_ENTITY.getClazz().cast(entity));
+		} catch (Exception e) {
+			throw new NBTException("Exception while getting the NMS Entity from a Bukkit Entity!", e);
+		}
+	}
+
+	/**
+	 * Reads in a InputStream as NMS Compound
+	 * 
+	 * @param stream InputStream of any NBT file
+	 * @return NMS Compound
+	 */
+	public static Object readNBT(InputStream stream) {
+		try (stream) {
+			return ReflectionMethod.NBTFILE_READ.run(null, stream);
+		} catch (Exception e) {
+			throw new NBTException("Exception while reading a NBT File!", e);
+		}
+	}
+
+	/**
+	 * Writes a NMS Compound to an OutputStream
+	 * 
+	 * @param nbt NMS Compound
+	 * @param stream Stream to write to
+	 * @return ???
+	 */
+	public static Object writeNBT(Object nbt, OutputStream stream) {
+		try {
+			return ReflectionMethod.NBTFILE_WRITE.run(null, nbt, stream);
+		} catch (Exception e) {
+			throw new NBTException("Exception while writing NBT!", e);
+		}
+	}
+
+	/**
+	 * Writes a Compound to an OutputStream
+	 * 
+	 * @param comp Compound
+	 * @param stream Stream to write to
+	 */
+	public static void writeApiNBT(NBTCompound comp, OutputStream stream) {
+		try {
+			Object nbttag = comp.getCompound();
+			if (nbttag == null) {
+				nbttag = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+			}
+			if (!valideCompound(comp))
+				return;
+			Object workingtag = getToCompount(nbttag, comp);
+			ReflectionMethod.NBTFILE_WRITE.run(null, workingtag, stream);
+		} catch (Exception e) {
+			throw new NBTException("Exception while writing NBT!", e);
+		}
+	}
+
+	/**
+	 * Simulates getOrCreateTag. If an Item doesn't yet have a Tag, it will return a
+	 * new empty tag.
+	 *
+	 * @return NMS Compound
+	 */
+	public static Object getItemRootNBTTagCompound(Object nmsItem) {
+		try {
+			Object answer = ReflectionMethod.NMSITEM_GETTAG.run(nmsItem);
+			return answer != null ? answer : ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		} catch (Exception e) {
+			throw new NBTException("Exception while getting an Itemstack's NBTCompound!", e);
+		}
+	}
+
+	/**
+	 * Converts {@link NBTCompound} to NMS ItemStacks
+	 * 
+	 * @param nbtcompound Any valid {@link NBTCompound}
+	 * @return NMS ItemStack
+	 */
+	public static Object convertNBTCompoundToNMSItem(NBTCompound nbtcompound) {
+		try {
+			Object nmsComp = getToCompount(nbtcompound.getCompound(), nbtcompound);
+			return ObjectCreator.NMS_COMPOUNDFROMITEM.getInstance(nmsComp);
+		} catch (Exception e) {
+			throw new NBTException("Exception while converting NBTCompound to NMS ItemStack!", e);
+		}
+	}
+
+	/**
+	 * Converts NMS ItemStacks to {@link NBTContainer}
+	 * 
+	 * @param nmsitem NMS ItemStack
+	 * @return {@link NBTContainer} with all the data
+	 */
+	public static NBTContainer convertNMSItemToNBTCompound(Object nmsitem) {
+		try {
+			Object answer = ReflectionMethod.NMSITEM_SAVE.run(nmsitem, ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance());
+			return new NBTContainer(answer);
+		} catch (Exception e) {
+			throw new NBTException("Exception while converting NMS ItemStack to NBTCompound!", e);
+		}
+	}
+
+	/**
+	 * Gets a live copy of non-vanilla NBT tags.
+	 *
+	 * @param meta ItemMeta from which tags should be retrieved
+	 * @return Map containing unhandled (custom) NBT tags
+	 */
+	@SuppressWarnings("unchecked")
+	public static Map<String, Object> getUnhandledNBTTags(ItemMeta meta) {
+		try {
+			return (Map<String, Object>) field_unhandledTags.get(meta);
+		} catch (Exception e) {
+			throw new NBTException("Exception while getting unhandled tags from ItemMeta!", e);
+		}
+	}
+
+	/**
+	 * Gets the Vanilla NBT Compound from a given NMS Entity
+	 *
+	 * @return NMS NBT Compound
+	 */
+	public static Object getEntityNBTTagCompound(Object nmsEntity) {
+		try {
+			Object nbt = ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz().newInstance();
+			Object answer = ReflectionMethod.NMS_ENTITY_GET_NBT.run(nmsEntity, nbt);
+			if (answer == null)
+				answer = nbt;
+			return answer;
+		} catch (Exception e) {
+			throw new NBTException("Exception while getting NBTCompound from NMS Entity!", e);
+		}
+	}
+
+	/**
+	 * Loads all Vanilla tags from a NMS Compound into a NMS Entity
+	 *
+	 * @return The NMS Entity
+	 */
+	public static Object setEntityNBTTag(Object nbtTag, Object nmsEntity) {
+		try {
+			ReflectionMethod.NMS_ENTITY_SET_NBT.run(nmsEntity, nbtTag);
+			return nmsEntity;
+		} catch (Exception ex) {
+			throw new NBTException("Exception while setting the NBTCompound of an Entity", ex);
+		}
+	}
+
+	/**
+	 * Gets the NMS Compound from a given TileEntity
+	 *
+	 * @return NMS Compound with the Vanilla data
+	 */
+	public static Object getTileEntityNBTTagCompound(BlockState tile) {
+		try {
+			Object cworld = ClassWrapper.CRAFT_WORLD.getClazz().cast(tile.getWorld());
+			Object nmsworld = ReflectionMethod.CRAFT_WORLD_GET_HANDLE.run(cworld);
+			Object pos = ObjectCreator.NMS_BLOCKPOSITION.getInstance(tile.getX(), tile.getY(), tile.getZ());
+			Object o = ReflectionMethod.NMS_WORLD_GET_TILEENTITY.run(nmsworld, pos);
+
+			Object answer = ReflectionMethod.TILEENTITY_GET_NBT_1181.run(o);
+			if (answer == null) {
+			    throw new NBTException("Unable to get NBTCompound from TileEntity! " + tile + " " + o);
+			}
+			return answer;
+		} catch (Exception e) {
+			throw new NBTException("Exception while getting NBTCompound from TileEntity!", e);
+		}
+	}
+
+	/**
+	 * Sets Vanilla tags from a NMS Compound to a TileEntity
+	 */
+	public static void setTileEntityNBTTagCompound(BlockState tile, Object comp) {
+		try {
+			Object cworld = ClassWrapper.CRAFT_WORLD.getClazz().cast(tile.getWorld());
+			Object nmsworld = ReflectionMethod.CRAFT_WORLD_GET_HANDLE.run(cworld);
+			Object pos = ObjectCreator.NMS_BLOCKPOSITION.getInstance(tile.getX(), tile.getY(), tile.getZ());
+			Object o = ReflectionMethod.NMS_WORLD_GET_TILEENTITY.run(nmsworld, pos);
+
+			ReflectionMethod.TILEENTITY_SET_NBT.run(o, comp);
+		} catch (Exception e) {
+			throw new NBTException("Exception while setting NBTData for a TileEntity!", e);
+		}
+	}
+
+	/**
+	 * Gets the subCompound with a given name from a NMS Compound
+	 *
+	 * @return NMS Compound or null
+	 */
+	public static Object getSubNBTTagCompound(Object compound, String name) {
+		try {
+			if ((boolean) ReflectionMethod.COMPOUND_HAS_KEY.run(compound, name)) {
+				return ReflectionMethod.COMPOUND_GET_COMPOUND.run(compound, name);
+			} else {
+				throw new NBTException("Tried getting invalid compound '" + name + "' from '" + compound + "'!");
+			}
+		} catch (Exception e) {
+			throw new NBTException("Exception while getting NBT subcompounds!", e);
+		}
+	}
+
+	/**
+	 * Creates a subCompound with a given name in the given NMS Compound
+	 */
+	public static void addNBTTagCompound(NBTCompound comp, String name) {
+		if (name == null) {
+			remove(comp, name);
+			return;
+		}
+		Object nbttag = comp.getCompound();
+		if (nbttag == null) {
+			nbttag = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		}
+		if (!valideCompound(comp)) {
+			return;
+		}
+		Object workingtag = getToCompount(nbttag, comp);
+		try {
+			ReflectionMethod.COMPOUND_SET.run(workingtag, name, ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz().newInstance());
+			comp.setCompound(nbttag);
+		} catch (Exception e) {
+			throw new NBTException("Exception while adding a Compound!", e);
+		}
+	}
+
+	/**
+	 * Checks if the Compound is correctly linked to it's roots
+	 *
+	 * @return true if this is a valide Compound, else false
+	 */
+	public static Boolean valideCompound(NBTCompound comp) {
+		Object root = comp.getCompound();
+		if (root == null) {
+			root = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		}
+		return (getToCompount(root, comp)) != null;
+	}
+
+	protected static Object getToCompount(Object nbttag, NBTCompound comp) {
+		Deque<String> structure = new ArrayDeque<>();
+		while (comp.getParent() != null) {
+			structure.add(comp.getName());
+			comp = comp.getParent();
+		}
+		while (!structure.isEmpty()) {
+			String target = structure.pollLast();
+			nbttag = getSubNBTTagCompound(nbttag, target);
+			if (nbttag == null) {
+				throw new NBTException("Unable to find tag '" + target + "' in " + nbttag);
+			}
+		}
+		return nbttag;
+	}
+
+	/**
+	 * Merges the second {@link NBTCompound} into the first one
+	 * 
+	 * @param comp Target for the merge
+	 * @param nbtcompoundSrc Data to merge
+	 */
+	public static void mergeOtherNBTCompound(NBTCompound comp, NBTCompound nbtcompoundSrc) {
+		Object rootnbttag = comp.getCompound();
+		if (rootnbttag == null) {
+			rootnbttag = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		}
+		if (!valideCompound(comp))
+			throw new NBTException("The Compound wasn't able to be linked back to the root!");
+		Object workingtag = getToCompount(rootnbttag, comp);
+		Object rootnbttagSrc = nbtcompoundSrc.getCompound();
+		if (rootnbttagSrc == null) {
+			rootnbttagSrc = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		}
+		if (!valideCompound(nbtcompoundSrc))
+			throw new NBTException("The Compound wasn't able to be linked back to the root!");
+		Object workingtagSrc = getToCompount(rootnbttagSrc, nbtcompoundSrc);
+		try {
+			ReflectionMethod.COMPOUND_MERGE.run(workingtag, workingtagSrc);
+			comp.setCompound(rootnbttag);
+		} catch (Exception e) {
+			throw new NBTException("Exception while merging two NBTCompounds!", e);
+		}
+	}
+
+	/**
+	 * Returns the content for a given key inside a Compound
+	 *
+	 * @return Content saved under this key
+	 */
+	public static String getContent(NBTCompound comp, String key) {
+		Object rootnbttag = comp.getCompound();
+		if (rootnbttag == null) {
+			rootnbttag = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		}
+		if (!valideCompound(comp))
+			throw new NBTException("The Compound wasn't able to be linked back to the root!");
+		Object workingtag = getToCompount(rootnbttag, comp);
+		try {
+			return ReflectionMethod.COMPOUND_GET.run(workingtag, key).toString();
+		} catch (Exception e) {
+			throw new NBTException("Exception while getting the Content for key '" + key + "'!", e);
+		}
+	}
+
+	/**
+	 * Sets a key in a {@link NBTCompound} to a given value
+	 */
+	public static void set(NBTCompound comp, String key, Object val) {
+		if (val == null) {
+			remove(comp, key);
+			return;
+		}
+		Object rootnbttag = comp.getCompound();
+		if (rootnbttag == null) {
+			rootnbttag = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		}
+		if (!valideCompound(comp)) {
+			throw new NBTException("The Compound wasn't able to be linked back to the root!");
+		}
+		Object workingtag = getToCompount(rootnbttag, comp);
+		try {
+			ReflectionMethod.COMPOUND_SET.run(workingtag, key, val);
+			comp.setCompound(rootnbttag);
+		} catch (Exception e) {
+			throw new NBTException("Exception while setting key '" + key + "' to '" + val + "'!", e);
+		}
+	}
+
+	/**
+	 * Returns the List saved with a given key.
+	 *
+	 * @return The list at that key. Null if it's an invalide type
+	 */
+	@SuppressWarnings("unchecked")
+	public static <T> NBTList<T> getList(NBTCompound comp, String key, NBTType type, Class<T> clazz) {
+		Object rootnbttag = comp.getCompound();
+		if (rootnbttag == null) {
+			rootnbttag = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		}
+		if (!valideCompound(comp))
+			return null;
+		Object workingtag = getToCompount(rootnbttag, comp);
+		try {
+			Object nbt = ReflectionMethod.COMPOUND_GET_LIST.run(workingtag, key, type.getId());
+			if (clazz == String.class) {
+				return (NBTList<T>) new NBTStringList(comp, key, type, nbt);
+			} else if (clazz == NBTListCompound.class) {
+				return (NBTList<T>) new NBTCompoundList(comp, key, type, nbt);
+			} else if (clazz == Integer.class) {
+				return (NBTList<T>) new NBTIntegerList(comp, key, type, nbt);
+			} else if (clazz == Float.class) {
+				return (NBTList<T>) new NBTFloatList(comp, key, type, nbt);
+			} else if (clazz == Double.class) {
+				return (NBTList<T>) new NBTDoubleList(comp, key, type, nbt);
+			} else if (clazz == Long.class) {
+				return (NBTList<T>) new NBTLongList(comp, key, type, nbt);
+            } else if (clazz == int[].class) {
+                return (NBTList<T>) new NBTIntArrayList(comp, key, type, nbt);
+            } else if (clazz == UUID.class) {
+                return (NBTList<T>) new NBTUUIDList(comp, key, type, nbt);
+			} else {
+				return null;
+			}
+		} catch (Exception ex) {
+			throw new NBTException("Exception while getting a list with the type '" + type + "'!", ex);
+		}
+	}
+
+	public static NBTType getListType(NBTCompound comp, String key) {
+		Object rootnbttag = comp.getCompound();
+		if (rootnbttag == null) {
+			rootnbttag = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		}
+		if (!valideCompound(comp))
+			return null;
+		Object workingtag = getToCompount(rootnbttag, comp);
+		try {
+			Object nbt = ReflectionMethod.COMPOUND_GET.run(workingtag, key);
+			String fieldname = "w";
+			Field f = nbt.getClass().getDeclaredField(fieldname);
+			f.setAccessible(true);
+			return NBTType.valueOf(f.getByte(nbt));
+		} catch (Exception ex) {
+			throw new NBTException("Exception while getting the list type!", ex);
+		}
+	}
+
+	public static Object getEntry(NBTCompound comp, String key) {
+		Object rootnbttag = comp.getCompound();
+		if (rootnbttag == null) {
+			rootnbttag = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		}
+		if (!valideCompound(comp))
+			return null;
+		Object workingtag = getToCompount(rootnbttag, comp);
+		try {
+			return ReflectionMethod.COMPOUND_GET.run(workingtag, key);
+		} catch (Exception ex) {
+			throw new NBTException("Exception while getting an Entry!", ex);
+		}
+	}
+
+	/**
+	 * Uses Gson to set a {@link Serializable} value in a Compound
+	 */
+	public static void setObject(NBTCompound comp, String key, Object value) {
+		try {
+			String json = GsonWrapper.getString(value);
+			setData(comp, ReflectionMethod.COMPOUND_SET_STRING, key, json);
+		} catch (Exception e) {
+			throw new NBTException("Exception while setting the Object '" + value + "'!", e);
+		}
+	}
+
+	/**
+	 * Uses Gson to load back a {@link Serializable} object from the Compound
+	 *
+	 * @return The loaded Object or null, if not found
+	 */
+	public static <T> T getObject(NBTCompound comp, String key, Class<T> type) {
+		String json = (String) getData(comp, ReflectionMethod.COMPOUND_GET_STRING, key);
+		if (json == null) {
+			return null;
+		}
+		return GsonWrapper.deserializeJson(json, type);
+	}
+
+	/**
+	 * Deletes the given key
+	 */
+	public static void remove(NBTCompound comp, String key) {
+		Object rootnbttag = comp.getCompound();
+		if (rootnbttag == null) {
+			rootnbttag = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		}
+		if (!valideCompound(comp))
+			return;
+		Object workingtag = getToCompount(rootnbttag, comp);
+		ReflectionMethod.COMPOUND_REMOVE_KEY.run(workingtag, key);
+		comp.setCompound(rootnbttag);
+	}
+
+	/**
+	 * Gets the Keyset inside this Compound
+	 *
+	 * @return Set of all keys
+	 */
+	@SuppressWarnings("unchecked")
+	public static Set<String> getKeys(NBTCompound comp) {
+		Object rootnbttag = comp.getCompound();
+		if (rootnbttag == null) {
+			rootnbttag = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		}
+		if (!valideCompound(comp))
+			throw new NBTException("The Compound wasn't able to be linked back to the root!");
+		Object workingtag = getToCompount(rootnbttag, comp);
+		return (Set<String>) ReflectionMethod.COMPOUND_GET_KEYS.run(workingtag);
+	}
+
+	/**
+	 * Sets data inside the Compound
+	 */
+	public static void setData(NBTCompound comp, ReflectionMethod type, String key, Object data) {
+		if (data == null) {
+			remove(comp, key);
+			return;
+		}
+		Object rootnbttag = comp.getCompound();
+		if (rootnbttag == null) {
+			rootnbttag = ObjectCreator.NMS_NBTTAGCOMPOUND.getInstance();
+		}
+		if (!valideCompound(comp))
+			throw new NBTException("The Compound wasn't able to be linked back to the root!");
+		Object workingtag = getToCompount(rootnbttag, comp);
+		type.run(workingtag, key, data);
+		comp.setCompound(rootnbttag);
+	}
+
+	/**
+	 * Gets data from the Compound
+	 *
+	 * @return The value or default fallback from NMS
+	 */
+	public static Object getData(NBTCompound comp, ReflectionMethod type, String key) {
+		Object rootnbttag = comp.getCompound();
+		if (rootnbttag == null) {
+			return null;
+		}
+		if (!valideCompound(comp))
+			throw new NBTException("The Compound wasn't able to be linked back to the root!");
+		Object workingTag = getToCompount(rootnbttag, comp);
+		return type.run(workingTag, key);
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTStringList.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTStringList.java
new file mode 100644
index 0000000000000000000000000000000000000000..f4a258573b23eb8b986aa6e7003396bebd6eb8ca
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTStringList.java
@@ -0,0 +1,41 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ClassWrapper;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+
+/**
+ * String implementation for NBTLists
+ *
+ * @author tr7zw
+ */
+public class NBTStringList extends NBTList<String> {
+
+	protected NBTStringList(NBTCompound owner, String name, NBTType type, Object list) {
+		super(owner, name, type, list);
+	}
+
+	@Override
+	public String get(int index) {
+		try {
+			return (String) ReflectionMethod.LIST_GET_STRING.run(listObject, index);
+		} catch (Exception ex) {
+			throw new NBTException(ex);
+		}
+	}
+
+	@Override
+	protected Object asTag(String object) {
+		try {
+			Constructor<?> con = ClassWrapper.NMS_NBTTAGSTRING.getClazz().getDeclaredConstructor(String.class);
+			con.setAccessible(true);
+			return con.newInstance(object);
+		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
+				| NoSuchMethodException | SecurityException e) {
+			throw new NBTException("Error while wrapping the Object " + object + " to it's NMS object!", e);
+		}
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTTileEntity.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTTileEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..a5e2d396977d117f7b0d596c61849c7120812bc7
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTTileEntity.java
@@ -0,0 +1,60 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import org.bukkit.Bukkit;
+import org.bukkit.block.BlockState;
+
+/**
+ * NBT class to access vanilla tags from TileEntities. TileEntities don't
+ * support custom tags. Use the NBTInjector for custom tags. Changes will be
+ * instantly applied to the Tile, use the merge method to do many things at
+ * once.
+ *
+ * @author tr7zw
+ */
+public class NBTTileEntity extends NBTCompound {
+
+	private final BlockState tile;
+
+	/**
+	 * @param tile BlockState from any TileEntity
+	 */
+	public NBTTileEntity(BlockState tile) {
+		super(null, null);
+		if (tile == null || (!tile.isPlaced())) {
+			throw new NullPointerException("Tile can't be null/not placed!");
+		}
+		this.tile = tile;
+	}
+
+	@Override
+	public Object getCompound() {
+        if (!Bukkit.isPrimaryThread()) {
+            throw new NBTException("Entity NBT needs to be accessed sync!");
+        }
+		return NBTReflectionUtil.getTileEntityNBTTagCompound(tile);
+	}
+
+	@Override
+	protected void setCompound(Object compound) {
+        if (!Bukkit.isPrimaryThread()) {
+            throw new NBTException("Entity NBT needs to be accessed sync!");
+        }
+		NBTReflectionUtil.setTileEntityNBTTagCompound(tile, compound);
+	}
+
+	/**
+	 * Gets the NBTCompound used by spigots PersistentDataAPI.
+	 * 
+	 * @return NBTCompound containing the data of the PersistentDataAPI
+	 */
+	public NBTCompound getPersistentDataContainer() {
+		if (!hasKey("PublicBukkitValues")) {
+			NBTContainer container = new NBTContainer();
+			container.addCompound("PublicBukkitValues").setString("__nbtapi",
+					"Marker to make the PersistentDataContainer have content");
+			mergeCompound(container);
+		}
+		return getCompound("PublicBukkitValues");
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTType.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTType.java
new file mode 100644
index 0000000000000000000000000000000000000000..1e21e6aa1bf320c282584c6cb2825f4f8d9f76e4
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTType.java
@@ -0,0 +1,45 @@
+package io.sapphiremc.sapphire.api.nbt;
+
+/**
+ * Enum of all NBT Types Minecraft contains
+ *
+ * @author tr7zw
+ */
+public enum NBTType {
+	NBTTagEnd(0),
+    NBTTagByte(1),
+	NBTTagShort(2), 
+	NBTTagInt(3), 
+	NBTTagLong(4), 
+	NBTTagFloat(5), 
+	NBTTagDouble(6),
+	NBTTagByteArray(7), 
+	NBTTagIntArray(11), 
+	NBTTagString(8), 
+	NBTTagList(9), 
+	NBTTagCompound(10);
+
+	NBTType(int i) {
+		id = i;
+	}
+
+	private final int id;
+
+	/**
+	 * @return Id used by Minecraft internally
+	 */
+	public int getId() {
+		return id;
+	}
+
+	/**
+	 * @param id Internal Minecraft id
+	 * @return Enum representing the id, NBTTagEnd for invalide ids
+	 */
+	public static NBTType valueOf(int id) {
+		for (NBTType t : values())
+			if (t.getId() == id)
+				return t;
+		return NBTType.NBTTagEnd;
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTUUIDList.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTUUIDList.java
new file mode 100644
index 0000000000000000000000000000000000000000..55862592095bf4cefb2657824b5616070ed2b6da
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/NBTUUIDList.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.sapphire.api.nbt;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import io.sapphiremc.sapphire.api.nbt.utils.UUIDUtil;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ClassWrapper;
+import io.sapphiremc.sapphire.api.nbt.utils.nmsmappings.ReflectionMethod;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.UUID;
+
+/**
+ * UUID implementation for NBTLists
+ *
+ * @author tr7zw
+ */
+public class NBTUUIDList extends NBTList<UUID> {
+
+    private final NBTContainer tmpContainer;
+
+    protected NBTUUIDList(NBTCompound owner, String name, NBTType type, Object list) {
+        super(owner, name, type, list);
+        this.tmpContainer = new NBTContainer();
+    }
+
+    @Override
+    protected Object asTag(UUID object) {
+        try {
+            Constructor<?> con = ClassWrapper.NMS_NBTTAGINTARRAY.getClazz().getDeclaredConstructor(int[].class);
+            con.setAccessible(true);
+            return con.newInstance(UUIDUtil.uuidToIntArray(object));
+        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
+            | NoSuchMethodException | SecurityException e) {
+            throw new NBTException("Error while wrapping the Object " + object + " to it's NMS object!", e);
+        }
+    }
+
+    @Override
+    public UUID get(int index) {
+        try {
+            Object obj = ReflectionMethod.LIST_GET.run(listObject, index);
+            ReflectionMethod.COMPOUND_SET.run(tmpContainer.getCompound(), "tmp", obj);
+            int[] val = tmpContainer.getIntArray("tmp");
+            tmpContainer.removeKey("tmp");
+            return UUIDUtil.uuidFromIntArray(val);
+        } catch (NumberFormatException nf) {
+            return null;
+        } catch (Exception ex) {
+            throw new NBTException(ex);
+        }
+    }
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/exceptions/NBTException.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/exceptions/NBTException.java
new file mode 100644
index 0000000000000000000000000000000000000000..30d6982032c7575481e466ab46c2368ee5a089f2
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/exceptions/NBTException.java
@@ -0,0 +1,56 @@
+package io.sapphiremc.sapphire.api.nbt.exceptions;
+
+import io.sapphiremc.sapphire.api.nbt.utils.MinecraftVersion;
+import java.io.Serial;
+
+/**
+ * A generic {@link RuntimeException} that can be thrown by most methods in the
+ * NBTAPI.
+ *
+ * @author tr7zw
+ */
+public class NBTException extends RuntimeException {
+
+	@Serial
+	private static final long serialVersionUID = -993309714559452334L;
+    /**
+     * Keep track of the plugin selfcheck.
+     * Null = not checked(silentquickstart/shaded)
+     * true = selfcheck failed
+     * false = everything should be fine, but apparently wasn't?
+     */
+    public static Boolean confirmedBroken = null;
+
+	public NBTException() {
+		super();
+	}
+
+	public NBTException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
+        super(generateMessage(message), cause, enableSuppression, writableStackTrace);
+	}
+
+	public NBTException(String message, Throwable cause) {
+        super(generateMessage(message), cause);
+	}
+
+	public NBTException(String message) {
+        super(generateMessage(message));
+	}
+
+	public NBTException(Throwable cause) {
+        super(generateMessage(cause == null ? null : cause.toString()), cause);
+    }
+
+    private static String generateMessage(String message) {
+        if (message == null) return null;
+
+        if (confirmedBroken == null) {
+            return "[?]" + message;
+        } else if (confirmedBroken == false) {
+            return "[Selfchecked]" + message;
+        }
+
+        return "[NBTAPI|" + MinecraftVersion.getVersion() + "] There were errors detected during the server self-check! Please, make sure that NBT-API is up to date. Error message: " + message;
+    }
+
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/GsonWrapper.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/GsonWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..96fde82cf77626eeab363704fdcc851342bdfcc0
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/GsonWrapper.java
@@ -0,0 +1,43 @@
+package io.sapphiremc.sapphire.api.nbt.utils;
+
+import com.google.gson.Gson;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+
+public class GsonWrapper {
+
+	/**
+	 * Private constructor
+	 */
+	private GsonWrapper() {
+	}
+
+	private static final Gson gson = new Gson();
+
+	/**
+	 * Turns Objects into Json Strings
+	 *
+	 * @return Json, representing the Object
+	 */
+	public static String getString(Object obj) {
+		return gson.toJson(obj);
+	}
+
+	/**
+	 * Creates an Object of the given type using the Json String
+	 *
+	 * @return Object that got created, or null if the json is null
+	 */
+	public static <T> T deserializeJson(String json, Class<T> type) {
+		try {
+			if (json == null) {
+				return null;
+			}
+
+			T obj = gson.fromJson(json, type);
+			return type.cast(obj);
+		} catch (Exception ex) {
+			throw new NBTException("Error while converting json to " + type.getName(), ex);
+		}
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/MinecraftVersion.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/MinecraftVersion.java
new file mode 100644
index 0000000000000000000000000000000000000000..12333a24802880fc67b761dcdf0507aaeba11f0b
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/MinecraftVersion.java
@@ -0,0 +1,95 @@
+package io.sapphiremc.sapphire.api.nbt.utils;
+
+import org.bukkit.Bukkit;
+
+/**
+ * This class acts as the "Brain" of the NBTApi. It contains the main logger for
+ * other classes and checks rather Maven shading was done
+ * correctly.
+ *
+ * @author tr7zw
+ */
+public enum MinecraftVersion {
+	UNKNOWN(-1), // Use the newest known mappings
+	v1_12_R1(1121),
+	v1_13_R1(1131),
+	v1_13_R2(1132),
+	v1_14_R1(1141),
+	v1_15_R1(1151),
+	v1_16_R1(1161),
+	v1_16_R2(1162),
+	v1_16_R3(1163),
+	v1_17_R1(1171),
+	v1_18_R1(1181, true),
+    v1_18_R2(1182, true),
+    v1_19_R1(1191, true);
+
+	private static MinecraftVersion version;
+
+	private final int versionId;
+	private final boolean mojangMapping;
+
+    MinecraftVersion(int versionId) {
+        this(versionId, false);
+    }
+
+	MinecraftVersion(int versionId, boolean mojangMapping) {
+		this.versionId = versionId;
+		this.mojangMapping = mojangMapping;
+	}
+
+	/**
+	 * @return A simple comparable Integer, representing the version.
+	 */
+	public int getVersionId() {
+		return versionId;
+	}
+
+	/**
+	 * @return True if method names are in Mojang format and need to be remapped internally
+	 */
+	public boolean isMojangMapping() {
+        return mojangMapping;
+    }
+
+    /**
+     * This method is required to hot-wire the plugin during mappings generation for newer mc versions thanks to md_5 not used mojmap.
+     */
+	public String getPackageName() {
+	    if (this == UNKNOWN) {
+            return Bukkit.getServer().getClass().getPackage().getName().split("\\.")[3];
+	    }
+	    return this.name();
+	}
+
+    /**
+	 * Returns true if the current versions is at least the given Version
+	 * 
+	 * @param version The minimum version
+	 */
+	public static boolean isAtLeast(MinecraftVersion version) {
+		return getVersion().getVersionId() >= version.getVersionId();
+	}
+
+	/**
+	 * Returns true if the current versions newer (not equal) than the given version
+	 * 
+	 * @param version The minimum version
+	 */
+	public static boolean isNewerThan(MinecraftVersion version) {
+		return getVersion().getVersionId() > version.getVersionId();
+	}
+
+	/**
+	 * Getter for this server MinecraftVersion.
+	 * 
+	 * @return The enum for the MinecraftVersion this server is running
+	 */
+	public static MinecraftVersion getVersion() {
+        if (version == null) {
+            version = MinecraftVersion.values()[MinecraftVersion.values().length - 1];
+        }
+
+        return version;
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/ReflectionUtil.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/ReflectionUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..81808bdb0fde909e2c72009c529b0738535882e9
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/ReflectionUtil.java
@@ -0,0 +1,51 @@
+package io.sapphiremc.sapphire.api.nbt.utils;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+
+public final class ReflectionUtil {
+
+	private static Field field_modifiers;
+
+	static {
+		try {
+			field_modifiers = Field.class.getDeclaredField("modifiers");
+			field_modifiers.setAccessible(true);
+		} catch (NoSuchFieldException ex) {
+			try {
+				// This hacky workaround is for newer jdk versions 11+?
+				Method fieldGetter = Class.class.getDeclaredMethod("getDeclaredFields0", boolean.class);
+				fieldGetter.setAccessible(true);
+				Field[] fields = (Field[]) fieldGetter.invoke(Field.class, false);
+				for (Field f : fields)
+					if (f.getName().equals("modifiers")) {
+						field_modifiers = f;
+						field_modifiers.setAccessible(true);
+						break;
+					}
+			} catch (Exception e) {
+				throw new NBTException(e);
+			}
+		}
+		if (field_modifiers == null) {
+			throw new NBTException("Unable to init the modifiers Field.");
+		}
+	}
+
+	public static void makeNonFinal(Field field) throws IllegalArgumentException, IllegalAccessException {
+		int mods = field.getModifiers();
+		if (Modifier.isFinal(mods)) {
+			field_modifiers.set(field, mods & ~Modifier.FINAL);
+		}
+	}
+
+	public static void setFinal(Object obj, Field field, Object newValue)
+			throws IllegalArgumentException, IllegalAccessException {
+		field.setAccessible(true);
+		makeNonFinal(field);
+		field.set(obj, newValue);
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/UUIDUtil.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/UUIDUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..d238e785f67a3cbc52e100d3db96f1f3d15ed481
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/UUIDUtil.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.sapphire.api.nbt.utils;
+
+import java.util.UUID;
+
+public class UUIDUtil {
+
+    public static UUID uuidFromIntArray(int[] is) {
+        return new UUID((long) is[0] << 32 | (long) is[1] & 4294967295L,
+            (long) is[2] << 32 | (long) is[3] & 4294967295L);
+    }
+
+    public static int[] uuidToIntArray(UUID uUID) {
+        long l = uUID.getMostSignificantBits();
+        long m = uUID.getLeastSignificantBits();
+        return leastMostToIntArray(l, m);
+    }
+
+    private static int[] leastMostToIntArray(long l, long m) {
+        return new int[]{(int) (l >> 32), (int) l, (int) (m >> 32), (int) m};
+    }
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ClassWrapper.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ClassWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..1557af265818adf258c6d9dac24f04ecbc5447ae
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ClassWrapper.java
@@ -0,0 +1,94 @@
+package io.sapphiremc.sapphire.api.nbt.utils.nmsmappings;
+
+import java.util.logging.Level;
+
+import io.sapphiremc.sapphire.api.nbt.utils.MinecraftVersion;
+import org.bukkit.Bukkit;
+
+/**
+ * Wraps NMS and CRAFT classes
+ * 
+ * @author tr7zw
+ */
+public enum ClassWrapper {
+    CRAFT_ITEMSTACK(PackageWrapper.CRAFTBUKKIT, "inventory.CraftItemStack", null, null),
+    CRAFT_METAITEM(PackageWrapper.CRAFTBUKKIT, "inventory.CraftMetaItem", null, null),
+    CRAFT_ENTITY(PackageWrapper.CRAFTBUKKIT, "entity.CraftEntity", null, null),
+    CRAFT_WORLD(PackageWrapper.CRAFTBUKKIT, "CraftWorld", null, null),
+    CRAFT_PERSISTENTDATACONTAINER(PackageWrapper.CRAFTBUKKIT, "persistence.CraftPersistentDataContainer", MinecraftVersion.v1_14_R1, null),
+    NMS_NBTBASE(PackageWrapper.NMS, "NBTBase", null, null, "net.minecraft.nbt", "net.minecraft.nbt.Tag"),
+    NMS_NBTTAGSTRING(PackageWrapper.NMS, "NBTTagString", null, null, "net.minecraft.nbt", "net.minecraft.nbt.StringTag"),
+    NMS_NBTTAGINT(PackageWrapper.NMS, "NBTTagInt", null, null, "net.minecraft.nbt", "net.minecraft.nbt.IntTag"),
+    NMS_NBTTAGINTARRAY(PackageWrapper.NMS, "NBTTagIntArray", null, null, "net.minecraft.nbt", "net.minecraft.nbt.IntArrayTag"),
+    NMS_NBTTAGFLOAT(PackageWrapper.NMS, "NBTTagFloat", null, null, "net.minecraft.nbt", "net.minecraft.nbt.FloatTag"),
+    NMS_NBTTAGDOUBLE(PackageWrapper.NMS, "NBTTagDouble", null, null, "net.minecraft.nbt", "net.minecraft.nbt.DoubleTag"),
+    NMS_NBTTAGLONG(PackageWrapper.NMS, "NBTTagLong", null, null, "net.minecraft.nbt", "net.minecraft.nbt.LongTag"),
+    NMS_ITEMSTACK(PackageWrapper.NMS, "ItemStack", null, null, "net.minecraft.world.item", "net.minecraft.world.item.ItemStack"),
+    NMS_NBTTAGCOMPOUND(PackageWrapper.NMS, "NBTTagCompound", null, null, "net.minecraft.nbt", "net.minecraft.nbt.CompoundTag"),
+    NMS_NBTTAGLIST(PackageWrapper.NMS, "NBTTagList", null, null, "net.minecraft.nbt", "net.minecraft.nbt.ListTag"),
+    NMS_NBTCOMPRESSEDSTREAMTOOLS(PackageWrapper.NMS, "NBTCompressedStreamTools", null, null, "net.minecraft.nbt", "net.minecraft.nbt.NbtIo"),
+    NMS_MOJANGSONPARSER(PackageWrapper.NMS, "MojangsonParser", null, null, "net.minecraft.nbt", "net.minecraft.nbt.TagParser"),
+    NMS_TILEENTITY(PackageWrapper.NMS, "TileEntity", null, null, "net.minecraft.world.level.block.entity", "net.minecraft.world.level.block.entity.BlockEntity"),
+    NMS_BLOCKPOSITION(PackageWrapper.NMS, "BlockPosition", MinecraftVersion.v1_12_R1, null, "net.minecraft.core", "net.minecraft.core.BlockPos"),
+    NMS_WORLDSERVER(PackageWrapper.NMS, "WorldServer", null, null, "net.minecraft.server.level", "net.minecraft.server.level.ServerLevel"),
+    NMS_MINECRAFTSERVER(PackageWrapper.NMS, "MinecraftServer", null, null, "net.minecraft.server", "net.minecraft.server.MinecraftServer"),
+    NMS_WORLD(PackageWrapper.NMS, "World", null, null, "net.minecraft.world.level", "net.minecraft.world.level.Level"),
+    NMS_ENTITY(PackageWrapper.NMS, "Entity", null, null, "net.minecraft.world.entity", "net.minecraft.world.entity.Entity"),
+    NMS_ENTITYTYPES(PackageWrapper.NMS, "EntityTypes", null, null, "net.minecraft.world.entity", "net.minecraft.world.entity.EntityType"),
+    NMS_REGISTRYSIMPLE(PackageWrapper.NMS, "RegistrySimple", MinecraftVersion.v1_12_R1, MinecraftVersion.v1_12_R1),
+    NMS_REGISTRYMATERIALS(PackageWrapper.NMS, "RegistryMaterials", null, null, "net.minecraft.core", "net.minecraft.core.MappedRegistry"),
+    NMS_IREGISTRY(PackageWrapper.NMS, "IRegistry", null, null, "net.minecraft.core", "net.minecraft.core.Registry"),
+    NMS_MINECRAFTKEY(PackageWrapper.NMS, "MinecraftKey", MinecraftVersion.v1_12_R1, null, "net.minecraft.resources", "net.minecraft.resources.ResourceKey"),
+    NMS_GAMEPROFILESERIALIZER(PackageWrapper.NMS, "GameProfileSerializer", null, null, "net.minecraft.nbt", "net.minecraft.nbt.NbtUtils"),
+    NMS_IBLOCKDATA(PackageWrapper.NMS, "IBlockData", MinecraftVersion.v1_12_R1, null, "net.minecraft.world.level.block.state", "net.minecraft.world.level.block.state.BlockState"),
+    GAMEPROFILE(PackageWrapper.NONE, "com.mojang.authlib.GameProfile", MinecraftVersion.v1_12_R1, null);
+
+    private Class<?> clazz;
+    private boolean enabled = false;
+    private final String mojangName;
+
+    ClassWrapper(PackageWrapper packageId, String clazzName, MinecraftVersion from, MinecraftVersion to) {
+        this(packageId, clazzName, from, to, null, null);
+    }
+
+    ClassWrapper(PackageWrapper packageId, String clazzName, MinecraftVersion from, MinecraftVersion to, String mojangMap, String mojangName) {
+        this.mojangName = mojangName;
+        if ((from != null && MinecraftVersion.getVersion().getVersionId() < from.getVersionId())
+            || (to != null && MinecraftVersion.getVersion().getVersionId() > to.getVersionId())) return;
+
+        enabled = true;
+        try {
+            if (MinecraftVersion.isAtLeast(MinecraftVersion.v1_17_R1) && mojangMap != null) {
+                clazz = Class.forName(mojangMap + "." + clazzName);
+            } else if (packageId == PackageWrapper.NONE) {
+                clazz = Class.forName(clazzName);
+            } else {
+                String version = MinecraftVersion.getVersion().getPackageName();
+                clazz = Class.forName(packageId.getUri() + "." + version + "." + clazzName);
+            }
+        } catch (Throwable ex) {
+            Bukkit.getLogger().log(Level.WARNING, "Error while trying to resolve the class '" + clazzName + "'!", ex);
+        }
+    }
+
+    /**
+     * @return The wrapped class
+     */
+    public Class<?> getClazz() {
+        return clazz;
+    }
+
+    /**
+     * @return Is this class available in this Version
+     */
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    /**
+     * @return Package+Class name used by Mojang
+     */
+    public String getMojangName() {
+        return mojangName;
+    }
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/MojangToMapping.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/MojangToMapping.java
new file mode 100644
index 0000000000000000000000000000000000000000..95da341f4677d4f847c18cafb40941eafaca93b9
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/MojangToMapping.java
@@ -0,0 +1,95 @@
+package io.sapphiremc.sapphire.api.nbt.utils.nmsmappings;
+
+import io.sapphiremc.sapphire.api.nbt.utils.MinecraftVersion;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Temporary solution to hold Mojang to unmapped Spigot mappings.
+ * 
+ * @author tr7zw
+ */
+public class MojangToMapping {
+
+    private static final Map<String, String> MC1_18_R1 = new HashMap<>() {
+        {
+            put("net.minecraft.nbt.CompoundTag#contains(java.lang.String)", "e");
+            put("net.minecraft.nbt.CompoundTag#getCompound(java.lang.String)", "p");
+            put("net.minecraft.nbt.CompoundTag#getList(java.lang.String,int)", "c");
+            put("net.minecraft.nbt.CompoundTag#putByteArray(java.lang.String,byte[])", "a");
+            put("net.minecraft.nbt.CompoundTag#getDouble(java.lang.String)", "k");
+            put("net.minecraft.nbt.CompoundTag#putDouble(java.lang.String,double)", "a");
+            put("net.minecraft.nbt.CompoundTag#getByteArray(java.lang.String)", "m");
+            put("net.minecraft.nbt.CompoundTag#putInt(java.lang.String,int)", "a");
+            put("net.minecraft.nbt.CompoundTag#getIntArray(java.lang.String)", "n");
+            put("net.minecraft.nbt.CompoundTag#remove(java.lang.String)", "r");
+            put("net.minecraft.nbt.CompoundTag#get(java.lang.String)", "c");
+            put("net.minecraft.nbt.CompoundTag#put(java.lang.String,net.minecraft.nbt.Tag)", "a");
+            put("net.minecraft.nbt.CompoundTag#putBoolean(java.lang.String,boolean)", "a");
+            put("net.minecraft.nbt.CompoundTag#getTagType(java.lang.String)", "d");
+            put("net.minecraft.nbt.CompoundTag#putLong(java.lang.String,long)", "a");
+            put("net.minecraft.nbt.CompoundTag#getString(java.lang.String)", "l");
+            put("net.minecraft.nbt.CompoundTag#getInt(java.lang.String)", "h");
+            put("net.minecraft.nbt.CompoundTag#putString(java.lang.String,java.lang.String)", "a");
+            put("net.minecraft.nbt.CompoundTag#getByte(java.lang.String)", "f");
+            put("net.minecraft.nbt.CompoundTag#putIntArray(java.lang.String,int[])", "a");
+            put("net.minecraft.nbt.CompoundTag#getShort(java.lang.String)", "g");
+            put("net.minecraft.nbt.CompoundTag#putByte(java.lang.String,byte)", "a");
+            put("net.minecraft.nbt.CompoundTag#getAllKeys()", "d");
+            put("net.minecraft.nbt.CompoundTag#putUUID(java.lang.String,java.util.UUID)", "a");
+            put("net.minecraft.nbt.CompoundTag#putShort(java.lang.String,short)", "a");
+            put("net.minecraft.nbt.CompoundTag#getLong(java.lang.String)", "i");
+            put("net.minecraft.nbt.CompoundTag#putFloat(java.lang.String,float)", "a");
+            put("net.minecraft.nbt.CompoundTag#getBoolean(java.lang.String)", "q");
+            put("net.minecraft.nbt.CompoundTag#getUUID(java.lang.String)", "a");
+            put("net.minecraft.nbt.CompoundTag#getFloat(java.lang.String)", "j");
+            put("net.minecraft.nbt.ListTag#addTag(int,net.minecraft.nbt.Tag)", "b");
+            put("net.minecraft.nbt.ListTag#setTag(int,net.minecraft.nbt.Tag)", "a");
+            put("net.minecraft.nbt.ListTag#getString(int)", "j");
+            put("net.minecraft.nbt.ListTag#remove(int)", "remove");
+            put("net.minecraft.nbt.ListTag#getCompound(int)", "a");
+            put("net.minecraft.nbt.ListTag#size()", "size");
+            put("net.minecraft.nbt.ListTag#get(int)", "get");
+            put("net.minecraft.nbt.NbtIo#readCompressed(java.io.InputStream)", "a");
+            put("net.minecraft.nbt.NbtIo#writeCompressed(net.minecraft.nbt.CompoundTag,java.io.OutputStream)", "a");
+            put("net.minecraft.nbt.NbtUtils#readGameProfile(net.minecraft.nbt.CompoundTag)", "a");
+            put("net.minecraft.nbt.NbtUtils#writeGameProfile(net.minecraft.nbt.CompoundTag,com.mojang.authlib.GameProfile)", "a");
+            put("net.minecraft.nbt.TagParser#parseTag(java.lang.String)", "a");
+            put("net.minecraft.world.entity.Entity#getEncodeId()", "bk");
+            put("net.minecraft.world.entity.Entity#load(net.minecraft.nbt.CompoundTag)", "g");
+            put("net.minecraft.world.entity.Entity#saveWithoutId(net.minecraft.nbt.CompoundTag)", "f");
+            put("net.minecraft.world.item.ItemStack#setTag(net.minecraft.nbt.CompoundTag)", "c");
+            put("net.minecraft.world.item.ItemStack#getTag()", "s");
+            put("net.minecraft.world.item.ItemStack#save(net.minecraft.nbt.CompoundTag)", "b");
+            put("net.minecraft.world.level.block.entity.BlockEntity#saveWithId()", "n");
+            put("net.minecraft.world.level.block.entity.BlockEntity#getBlockState()", "q");
+            put("net.minecraft.world.level.block.entity.BlockEntity#load(net.minecraft.nbt.CompoundTag)", "a");
+            put("net.minecraft.server.level.ServerLevel#getBlockEntity(net.minecraft.core.BlockPos)", "c_");
+        }
+    };
+
+    private static final Map<String, String> MC1_18_R2 = new HashMap<>() {
+        {
+            putAll(MC1_18_R1);
+
+            put("net.minecraft.world.item.ItemStack#getTag()", "t");
+        }
+    };
+
+    private static final Map<String, String> MC1_19_R1 = new HashMap<>() {
+        {
+            putAll(MC1_18_R2);
+
+            put("net.minecraft.world.item.ItemStack#getTag()", "u");
+        }
+    };
+
+    public static Map<String, String> getMapping(){
+        return switch (MinecraftVersion.getVersion()) {
+            case v1_18_R1 -> MC1_18_R1;
+            case v1_18_R2 -> MC1_18_R2;
+            default -> MC1_19_R1; //throw new NbtApiException("This version of the NBTAPI is not compatible with this server version!");
+        };
+    }
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ObjectCreator.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ObjectCreator.java
new file mode 100644
index 0000000000000000000000000000000000000000..4f9195e3c323ac3639ce028f913f712c1d955824
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ObjectCreator.java
@@ -0,0 +1,50 @@
+package io.sapphiremc.sapphire.api.nbt.utils.nmsmappings;
+
+import java.lang.reflect.Constructor;
+import java.util.logging.Level;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import io.sapphiremc.sapphire.api.nbt.utils.MinecraftVersion;
+import org.bukkit.Bukkit;
+
+/**
+ * This Enum wraps Constructors for NMS classes
+ *
+ * @author tr7zw
+ */
+public enum ObjectCreator {
+	NMS_NBTTAGCOMPOUND(null, null, ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()),
+	NMS_BLOCKPOSITION(null, null, ClassWrapper.NMS_BLOCKPOSITION.getClazz(), int.class, int.class, int.class),
+	NMS_COMPOUNDFROMITEM(MinecraftVersion.v1_12_R1, null, ClassWrapper.NMS_ITEMSTACK.getClazz(), ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()),;
+
+	private Constructor<?> construct;
+	private Class<?> targetClass;
+
+	ObjectCreator(MinecraftVersion from, MinecraftVersion to, Class<?> clazz, Class<?>... args) {
+		if (clazz == null
+            || (from != null && MinecraftVersion.getVersion().getVersionId() < from.getVersionId())
+            || (to != null && MinecraftVersion.getVersion().getVersionId() > to.getVersionId()))
+            return;
+
+		try {
+			this.targetClass = clazz;
+			construct = clazz.getDeclaredConstructor(args);
+			construct.setAccessible(true);
+		} catch (Exception ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Unable to find the constructor for the class '" + clazz.getName() + "'", ex);
+		}
+	}
+
+	/**
+	 * Creates an Object instance with given args
+	 *
+	 * @return Object created
+	 */
+	public Object getInstance(Object... args) {
+		try {
+			return construct.newInstance(args);
+		} catch (Exception ex) {
+			throw new NBTException("Exception while creating a new instance of '" + targetClass + "'", ex);
+		}
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/PackageWrapper.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/PackageWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..adfd2cfc12f535f529dbb08a1d10320d2b7b3ec3
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/PackageWrapper.java
@@ -0,0 +1,25 @@
+package io.sapphiremc.sapphire.api.nbt.utils.nmsmappings;
+
+/**
+ * Package enum
+ * 
+ * @author tr7zw
+ */
+public enum PackageWrapper {
+	NMS(new String(new byte[] {'n', 'e', 't', '.', 'm', 'i', 'n', 'e', 'c', 'r', 'a', 'f', 't', '.', 's', 'e', 'r', 'v', 'e', 'r'})),
+	CRAFTBUKKIT(new String(new byte[] {'o', 'r', 'g', '.', 'b', 'u', 'k', 'k', 'i', 't', '.', 'c', 'r', 'a', 'f', 't', 'b', 'u', 'k', 'k', 'i', 't'})),
+	NONE("");
+
+	private final String uri;
+
+	PackageWrapper(String uri) {
+		this.uri = uri;
+	}
+
+	/**
+	 * @return The Uri for that package
+	 */
+	public String getUri() {
+		return uri;
+	}
+}
diff --git a/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ReflectionMethod.java b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ReflectionMethod.java
new file mode 100644
index 0000000000000000000000000000000000000000..ad967e654d6e3073912f8175d2a549ea9d3b5f7a
--- /dev/null
+++ b/src/main/java/io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ReflectionMethod.java
@@ -0,0 +1,218 @@
+package io.sapphiremc.sapphire.api.nbt.utils.nmsmappings;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.UUID;
+
+import org.bukkit.Bukkit;
+import org.bukkit.inventory.ItemStack;
+
+import io.sapphiremc.sapphire.api.nbt.exceptions.NBTException;
+import io.sapphiremc.sapphire.api.nbt.utils.MinecraftVersion;
+
+/**
+ * This class caches method reflections, keeps track of method name changes between versions and allows early checking for problems
+ * 
+ * @author tr7zw
+ */
+public enum ReflectionMethod {
+
+    COMPOUND_SET_FLOAT(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, float.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "setFloat"), new Since(MinecraftVersion.v1_18_R1, "putFloat(java.lang.String,float)")),
+    COMPOUND_SET_STRING(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "setString"), new Since(MinecraftVersion.v1_18_R1, "putString(java.lang.String,java.lang.String)")),
+    COMPOUND_SET_INT(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, int.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "setInt"), new Since(MinecraftVersion.v1_18_R1, "putInt(java.lang.String,int)")),
+    COMPOUND_SET_BYTEARRAY(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, byte[].class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "setByteArray"), new Since(MinecraftVersion.v1_18_R1, "putByteArray(java.lang.String,byte[])")),
+    COMPOUND_SET_INTARRAY(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, int[].class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "setIntArray"), new Since(MinecraftVersion.v1_18_R1, "putIntArray(java.lang.String,int[])")),
+    COMPOUND_SET_LONG(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, long.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "setLong"), new Since(MinecraftVersion.v1_18_R1, "putLong(java.lang.String,long)")),
+    COMPOUND_SET_SHORT(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, short.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "setShort"), new Since(MinecraftVersion.v1_18_R1, "putShort(java.lang.String,short)")),
+    COMPOUND_SET_BYTE(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, byte.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "setByte"), new Since(MinecraftVersion.v1_18_R1, "putByte(java.lang.String,byte)")),
+    COMPOUND_SET_DOUBLE(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, double.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "setDouble"), new Since(MinecraftVersion.v1_18_R1, "putDouble(java.lang.String,double)")),
+    COMPOUND_SET_BOOLEAN(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, boolean.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "setBoolean"), new Since(MinecraftVersion.v1_18_R1, "putBoolean(java.lang.String,boolean)")),
+    COMPOUND_SET_UUID(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, UUID.class}, MinecraftVersion.v1_16_R1, new Since(MinecraftVersion.v1_16_R1, "a"), new Since(MinecraftVersion.v1_18_R1, "putUUID(java.lang.String,java.util.UUID)")),
+    COMPOUND_MERGE(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "a"), new Since(MinecraftVersion.v1_18_R1, "put(java.lang.String,net.minecraft.nbt.Tag)")),
+    COMPOUND_SET(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, ClassWrapper.NMS_NBTBASE.getClazz()}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "set"), new Since(MinecraftVersion.v1_18_R1, "put(java.lang.String,net.minecraft.nbt.Tag)")),
+    COMPOUND_GET(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "get"), new Since(MinecraftVersion.v1_18_R1, "get(java.lang.String)")),
+    COMPOUND_GET_LIST(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class, int.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getList"), new Since(MinecraftVersion.v1_18_R1, "getList(java.lang.String,int)")),
+
+    COMPOUND_GET_FLOAT(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getFloat"), new Since(MinecraftVersion.v1_18_R1, "getFloat(java.lang.String)")),
+    COMPOUND_GET_STRING(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getString"), new Since(MinecraftVersion.v1_18_R1, "getString(java.lang.String)")),
+    COMPOUND_GET_INT(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getInt"), new Since(MinecraftVersion.v1_18_R1, "getInt(java.lang.String)")),
+    COMPOUND_GET_BYTEARRAY(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getByteArray"), new Since(MinecraftVersion.v1_18_R1, "getByteArray(java.lang.String)")),
+    COMPOUND_GET_INTARRAY(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getIntArray"), new Since(MinecraftVersion.v1_18_R1, "getIntArray(java.lang.String)")),
+    COMPOUND_GET_LONG(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getLong"), new Since(MinecraftVersion.v1_18_R1, "getLong(java.lang.String)")),
+    COMPOUND_GET_SHORT(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getShort"), new Since(MinecraftVersion.v1_18_R1, "getShort(java.lang.String)")),
+    COMPOUND_GET_BYTE(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getByte"), new Since(MinecraftVersion.v1_18_R1, "getByte(java.lang.String)")),
+    COMPOUND_GET_DOUBLE(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getDouble"), new Since(MinecraftVersion.v1_18_R1, "getDouble(java.lang.String)")),
+    COMPOUND_GET_BOOLEAN(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getBoolean"), new Since(MinecraftVersion.v1_18_R1, "getBoolean(java.lang.String)")),
+    COMPOUND_GET_UUID(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_16_R1, new Since(MinecraftVersion.v1_16_R1, "a"), new Since(MinecraftVersion.v1_18_R1, "getUUID(java.lang.String)")),
+    COMPOUND_GET_COMPOUND(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getCompound"), new Since(MinecraftVersion.v1_18_R1, "getCompound(java.lang.String)")),
+
+    NMSITEM_GETTAG(ClassWrapper.NMS_ITEMSTACK, new Class[] {}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getTag"), new Since(MinecraftVersion.v1_18_R1, "getTag()")),
+    NMSITEM_SAVE(ClassWrapper.NMS_ITEMSTACK, new Class[] {ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "save"), new Since(MinecraftVersion.v1_18_R1, "save(net.minecraft.nbt.CompoundTag)")),
+
+    COMPOUND_REMOVE_KEY(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "remove"), new Since(MinecraftVersion.v1_18_R1, "remove(java.lang.String)")),
+    COMPOUND_HAS_KEY(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "hasKey"), new Since(MinecraftVersion.v1_18_R1, "contains(java.lang.String)")),
+    COMPOUND_GET_TYPE(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "b"), new Since(MinecraftVersion.v1_12_R1, "d"), new Since(MinecraftVersion.v1_15_R1, "e"), new Since(MinecraftVersion.v1_16_R1, "d"), new Since(MinecraftVersion.v1_18_R1, "getTagType(java.lang.String)")),
+    COMPOUND_GET_KEYS(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "c"), new Since(MinecraftVersion.v1_13_R1, "getKeys"), new Since(MinecraftVersion.v1_18_R1, "getAllKeys()")),
+
+    LISTCOMPOUND_GET_KEYS(ClassWrapper.NMS_NBTTAGCOMPOUND, new Class[]{}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "c"), new Since(MinecraftVersion.v1_13_R1, "getKeys"), new Since(MinecraftVersion.v1_18_R1, "getAllKeys()")), // FIXME ?!?
+    LIST_REMOVE_KEY(ClassWrapper.NMS_NBTTAGLIST, new Class[]{int.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "a"), new Since(MinecraftVersion.v1_12_R1, "remove"), new Since(MinecraftVersion.v1_18_R1, "remove(int)")),
+    LIST_SIZE(ClassWrapper.NMS_NBTTAGLIST, new Class[]{}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "size"), new Since(MinecraftVersion.v1_18_R1, "size()")),
+    LIST_SET(ClassWrapper.NMS_NBTTAGLIST, new Class[]{int.class, ClassWrapper.NMS_NBTBASE.getClazz()}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "a"), new Since(MinecraftVersion.v1_13_R1, "set"), new Since(MinecraftVersion.v1_18_R1, "setTag(int,net.minecraft.nbt.Tag)")),
+    LEGACY_LIST_ADD(ClassWrapper.NMS_NBTTAGLIST, new Class[]{ClassWrapper.NMS_NBTBASE.getClazz()}, MinecraftVersion.v1_12_R1, MinecraftVersion.v1_13_R2, new Since(MinecraftVersion.v1_12_R1, "add")),
+    LIST_ADD(ClassWrapper.NMS_NBTTAGLIST, new Class[]{int.class, ClassWrapper.NMS_NBTBASE.getClazz()}, MinecraftVersion.v1_14_R1, new Since(MinecraftVersion.v1_14_R1, "add"), new Since(MinecraftVersion.v1_18_R1, "addTag(int,net.minecraft.nbt.Tag)")),
+    LIST_GET_STRING(ClassWrapper.NMS_NBTTAGLIST, new Class[]{int.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getString"), new Since(MinecraftVersion.v1_18_R1, "getString(int)")),
+    LIST_GET_COMPOUND(ClassWrapper.NMS_NBTTAGLIST, new Class[]{int.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "get"), new Since(MinecraftVersion.v1_18_R1, "getCompound(int)")),
+    LIST_GET(ClassWrapper.NMS_NBTTAGLIST, new Class[]{int.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "get"), new Since(MinecraftVersion.v1_12_R1, "i"), new Since(MinecraftVersion.v1_13_R1, "get"), new Since(MinecraftVersion.v1_18_R1, "get(int)")),
+
+    ITEMSTACK_SET_TAG(ClassWrapper.NMS_ITEMSTACK, new Class[]{ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "setTag"), new Since(MinecraftVersion.v1_18_R1, "setTag(net.minecraft.nbt.CompoundTag)")),
+    ITEMSTACK_NMSCOPY(ClassWrapper.CRAFT_ITEMSTACK, new Class[]{ItemStack.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "asNMSCopy")),
+    ITEMSTACK_BUKKITMIRROR(ClassWrapper.CRAFT_ITEMSTACK, new Class[]{ClassWrapper.NMS_ITEMSTACK.getClazz()}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "asCraftMirror")),
+
+    CRAFT_WORLD_GET_HANDLE(ClassWrapper.CRAFT_WORLD, new Class[]{}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getHandle")),
+    NMS_WORLD_GET_TILEENTITY(ClassWrapper.NMS_WORLDSERVER, new Class[]{ClassWrapper.NMS_BLOCKPOSITION.getClazz()}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getTileEntity"), new Since(MinecraftVersion.v1_18_R1, "getBlockEntity(net.minecraft.core.BlockPos)")),
+    NMS_WORLD_SET_TILEENTITY(ClassWrapper.NMS_WORLDSERVER, new Class[]{ClassWrapper.NMS_BLOCKPOSITION.getClazz(), ClassWrapper.NMS_TILEENTITY.getClazz()}, MinecraftVersion.v1_12_R1, MinecraftVersion.v1_16_R3, new Since(MinecraftVersion.v1_12_R1, "setTileEntity")),
+    NMS_WORLD_REMOVE_TILEENTITY(ClassWrapper.NMS_WORLDSERVER, new Class[]{ClassWrapper.NMS_BLOCKPOSITION.getClazz()}, MinecraftVersion.v1_12_R1, MinecraftVersion.v1_17_R1, new Since(MinecraftVersion.v1_12_R1, "s"), new Since(MinecraftVersion.v1_13_R1, "n"),  new Since(MinecraftVersion.v1_14_R1, "removeTileEntity")),
+
+    TILEENTITY_LOAD_LEGACY1121(ClassWrapper.NMS_TILEENTITY, new Class[]{ClassWrapper.NMS_WORLD.getClazz(), ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_12_R1, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "create")),
+    TILEENTITY_LOAD_LEGACY1151(ClassWrapper.NMS_TILEENTITY, new Class[]{ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_13_R1, MinecraftVersion.v1_15_R1, new Since(MinecraftVersion.v1_12_R1, "create")),
+    TILEENTITY_LOAD(ClassWrapper.NMS_TILEENTITY, new Class[]{ClassWrapper.NMS_IBLOCKDATA.getClazz(), ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_16_R1, MinecraftVersion.v1_16_R3, new Since(MinecraftVersion.v1_16_R1, "create")),
+
+    TILEENTITY_GET_NBT(ClassWrapper.NMS_TILEENTITY, new Class[]{ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_12_R1, MinecraftVersion.v1_17_R1, new Since(MinecraftVersion.v1_12_R1, "save")),
+    TILEENTITY_GET_NBT_1181(ClassWrapper.NMS_TILEENTITY, new Class[]{}, MinecraftVersion.v1_18_R1, new Since(MinecraftVersion.v1_18_R1, "saveWithId()")),
+    TILEENTITY_SET_NBT_LEGACY1151(ClassWrapper.NMS_TILEENTITY, new Class[]{ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_12_R1, MinecraftVersion.v1_15_R1, new Since(MinecraftVersion.v1_12_R1, "load")),
+    TILEENTITY_SET_NBT_LEGACY1161(ClassWrapper.NMS_TILEENTITY, new Class[]{ClassWrapper.NMS_IBLOCKDATA.getClazz(), ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_16_R1, MinecraftVersion.v1_16_R3, new Since(MinecraftVersion.v1_16_R1, "load")),
+    TILEENTITY_SET_NBT(ClassWrapper.NMS_TILEENTITY, new Class[]{ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_17_R1, new Since(MinecraftVersion.v1_16_R1, "load"), new Since(MinecraftVersion.v1_18_R1, "load(net.minecraft.nbt.CompoundTag)")),
+    TILEENTITY_GET_BLOCKDATA(ClassWrapper.NMS_TILEENTITY, new Class[]{}, MinecraftVersion.v1_16_R1, new Since(MinecraftVersion.v1_16_R1, "getBlock"), new Since(MinecraftVersion.v1_18_R1, "getBlockState()")),
+
+    CRAFT_ENTITY_GET_HANDLE(ClassWrapper.CRAFT_ENTITY, new Class[]{}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "getHandle")),
+    NMS_ENTITY_SET_NBT(ClassWrapper.NMS_ENTITY, new Class[]{ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "f"), new Since(MinecraftVersion.v1_16_R1, "load"), new Since(MinecraftVersion.v1_18_R1, "load(net.minecraft.nbt.CompoundTag)")),
+    NMS_ENTITY_GET_NBT(ClassWrapper.NMS_ENTITY, new Class[]{ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "e"), new Since(MinecraftVersion.v1_12_R1, "save"), new Since(MinecraftVersion.v1_18_R1, "saveWithoutId(net.minecraft.nbt.CompoundTag)")),
+    NMS_ENTITY_GETSAVEID(ClassWrapper.NMS_ENTITY, new Class[]{}, MinecraftVersion.v1_14_R1,new Since(MinecraftVersion.v1_14_R1, "getSaveID"), new Since(MinecraftVersion.v1_18_R1, "getEncodeId()")),
+
+    NBTFILE_READ(ClassWrapper.NMS_NBTCOMPRESSEDSTREAMTOOLS, new Class[]{InputStream.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "a"), new Since(MinecraftVersion.v1_18_R1, "readCompressed(java.io.InputStream)")),
+    NBTFILE_WRITE(ClassWrapper.NMS_NBTCOMPRESSEDSTREAMTOOLS, new Class[]{ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz(), OutputStream.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "a"), new Since(MinecraftVersion.v1_18_R1, "writeCompressed(net.minecraft.nbt.CompoundTag,java.io.OutputStream)")),
+
+    PARSE_NBT(ClassWrapper.NMS_MOJANGSONPARSER, new Class[]{String.class}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "parse"), new Since(MinecraftVersion.v1_18_R1, "parseTag(java.lang.String)")),
+    REGISTRY_KEYSET (ClassWrapper.NMS_REGISTRYSIMPLE, new Class[]{}, MinecraftVersion.v1_12_R1, MinecraftVersion.v1_13_R1, new Since(MinecraftVersion.v1_12_R1, "keySet")),
+    REGISTRY_GET (ClassWrapper.NMS_REGISTRYSIMPLE, new Class[]{Object.class}, MinecraftVersion.v1_12_R1, MinecraftVersion.v1_13_R1, new Since(MinecraftVersion.v1_12_R1, "get")),
+    REGISTRY_SET (ClassWrapper.NMS_REGISTRYSIMPLE, new Class[]{Object.class, Object.class}, MinecraftVersion.v1_12_R1, MinecraftVersion.v1_13_R1, new Since(MinecraftVersion.v1_12_R1, "a")), //FIXME: No Spigot mapping!
+    REGISTRY_GET_INVERSE (ClassWrapper.NMS_REGISTRYMATERIALS, new Class[]{Object.class}, MinecraftVersion.v1_12_R1, MinecraftVersion.v1_13_R1, new Since(MinecraftVersion.v1_12_R1, "b")), //FIXME: No Spigot mapping!
+    REGISTRYMATERIALS_KEYSET (ClassWrapper.NMS_REGISTRYMATERIALS, new Class[]{}, MinecraftVersion.v1_13_R1, MinecraftVersion.v1_17_R1, new Since(MinecraftVersion.v1_13_R1, "keySet")),
+    REGISTRYMATERIALS_GET (ClassWrapper.NMS_REGISTRYMATERIALS, new Class[]{ClassWrapper.NMS_MINECRAFTKEY.getClazz()}, MinecraftVersion.v1_13_R1, MinecraftVersion.v1_17_R1,  new Since(MinecraftVersion.v1_13_R1, "get")),
+    REGISTRYMATERIALS_GETKEY (ClassWrapper.NMS_REGISTRYMATERIALS, new Class[]{Object.class}, MinecraftVersion.v1_13_R2, MinecraftVersion.v1_17_R1, new Since(MinecraftVersion.v1_13_R2, "getKey")),
+
+    GAMEPROFILE_DESERIALIZE (ClassWrapper.NMS_GAMEPROFILESERIALIZER, new Class[]{ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "deserialize"), new Since(MinecraftVersion.v1_18_R1, "readGameProfile(net.minecraft.nbt.CompoundTag)")),
+    GAMEPROFILE_SERIALIZE (ClassWrapper.NMS_GAMEPROFILESERIALIZER, new Class[]{ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz(), ClassWrapper.GAMEPROFILE.getClazz()}, MinecraftVersion.v1_12_R1, new Since(MinecraftVersion.v1_12_R1, "serialize"), new Since(MinecraftVersion.v1_18_R1, "writeGameProfile(net.minecraft.nbt.CompoundTag,com.mojang.authlib.GameProfile)")),
+
+    CRAFT_PERSISTENT_DATA_CONTAINER_TO_TAG (ClassWrapper.CRAFT_PERSISTENTDATACONTAINER, new Class[]{}, MinecraftVersion.v1_14_R1, new Since(MinecraftVersion.v1_14_R1, "toTagCompound")),
+    CRAFT_PERSISTENT_DATA_CONTAINER_GET_MAP (ClassWrapper.CRAFT_PERSISTENTDATACONTAINER, new Class[]{}, MinecraftVersion.v1_14_R1, new Since(MinecraftVersion.v1_14_R1, "getRaw")),
+    CRAFT_PERSISTENT_DATA_CONTAINER_PUT_ALL (ClassWrapper.CRAFT_PERSISTENTDATACONTAINER, new Class[]{ClassWrapper.NMS_NBTTAGCOMPOUND.getClazz()}, MinecraftVersion.v1_14_R1, new Since(MinecraftVersion.v1_14_R1, "putAll")),;
+
+    private MinecraftVersion removedAfter;
+    private Since targetVersion;
+    private Method method;
+    private boolean loaded = false;
+    private boolean compatible = false;
+    private String methodName = null;
+    private ClassWrapper parentClassWrapper;
+
+    ReflectionMethod(ClassWrapper targetClass, Class<?>[] args, MinecraftVersion addedSince, MinecraftVersion removedAfter, Since... methodnames) {
+        this.removedAfter = removedAfter;
+        this.parentClassWrapper = targetClass;
+
+        if (!MinecraftVersion.isAtLeast(addedSince) || (this.removedAfter != null && MinecraftVersion.isNewerThan(removedAfter))) return;
+        compatible = true;
+
+    	MinecraftVersion server = MinecraftVersion.getVersion();
+        Since target = methodnames[0];
+        for (Since s : methodnames) {
+            if (s.version.getVersionId() <= server.getVersionId() && target.version.getVersionId() < s.version.getVersionId())
+                target = s;
+        }
+        targetVersion = target;
+
+        String targetMethodName = targetVersion.name;
+        try {
+            if (targetVersion.version.isMojangMapping())
+                targetMethodName = MojangToMapping.getMapping().getOrDefault(targetClass.getMojangName() + "#" + targetVersion.name, "Unmapped" + targetVersion.name);
+            method = targetClass.getClazz().getDeclaredMethod(targetMethodName, args);
+            method.setAccessible(true);
+            loaded = true;
+            methodName = targetVersion.name;
+        } catch (NullPointerException | NoSuchMethodException | SecurityException ex) {
+            try {
+                if (targetVersion.version.isMojangMapping())
+                    targetMethodName = MojangToMapping.getMapping().getOrDefault(targetClass.getMojangName() + "#" + targetVersion.name, "Unmapped" + targetVersion.name);
+                method = targetClass.getClazz().getMethod(targetMethodName, args);
+                method.setAccessible(true);
+                loaded = true;
+                methodName = targetVersion.name;
+            } catch (NullPointerException | NoSuchMethodException | SecurityException ex2) {
+                Bukkit.getLogger().warning("Unable to find the method '" + targetMethodName + "' in '" + (targetClass.getClazz() == null ? targetClass.getMojangName() : targetClass.getClazz().getSimpleName()) + "' Args: " + Arrays.toString(args) + " Enum: " + this);
+            }
+        }
+    }
+
+    ReflectionMethod(ClassWrapper targetClass, Class<?>[] args, MinecraftVersion addedSince, Since... methodNames) {
+    	this(targetClass, args, addedSince, null, methodNames);
+    }
+
+    /**
+     * Runs the method on a given target object using the given args.
+     *
+     * @return Value returned by the method
+     */
+    public Object run(Object target, Object... args) {
+        if (method == null)
+        	throw new NBTException("Method not loaded! '" + this + "'");
+    	try {
+            return method.invoke(target, args);
+        } catch (Exception ex) {
+            throw new NBTException("Error while calling the method '" + methodName + "', loaded: " + loaded + ", Enum: " + this + " Passed Class: " + target.getClass(), ex);
+        }
+    }
+
+    /**
+     * @return The MethodName, used in this Minecraft Version
+     */
+    public String getMethodName() {
+    	return methodName;
+    }
+
+    /**
+     * @return Has this method been linked
+     */
+    public boolean isLoaded() {
+        return loaded;
+    }
+
+    /**
+     * @return Is this method available in this Minecraft Version
+     */
+    public boolean isCompatible() {
+        return compatible;
+    }
+
+    public Since getSelectedVersionInfo() {
+        return targetVersion;
+    }
+
+    /**
+     * @return Get Wrapper of the parent class
+     */
+    public ClassWrapper getParentClassWrapper() {
+        return parentClassWrapper;
+    }
+
+    public static class Since {
+        public final MinecraftVersion version;
+        public final String name;
+        public Since(MinecraftVersion version, String name) {
+            this.version = version;
+            this.name = name;
+        }
+    }
+
+}
diff --git a/src/main/java/org/bukkit/Chunk.java b/src/main/java/org/bukkit/Chunk.java
index 049c36807d2a970842442c1b7517c06f3f150041..c562c5760e6e7cdae48d9b4067587786b7745c98 100644
--- a/src/main/java/org/bukkit/Chunk.java
+++ b/src/main/java/org/bukkit/Chunk.java
@@ -283,4 +283,16 @@ public interface Chunk extends PersistentDataHolder {
      * @return if the block is contained within
      */
     boolean contains(@NotNull BlockData block);
+
+    // Sapphire start
+    /**
+     * Returns a custom tag container of this chunk.
+     *
+     * @return custom NBT tags container
+     */
+    @NotNull
+    default io.sapphiremc.sapphire.api.nbt.NBTCompound getNBTCompound() {
+        return new io.sapphiremc.sapphire.api.nbt.NBTChunk(this).getPersistentDataContainer();
+    }
+    // Sapphire end
 }
diff --git a/src/main/java/org/bukkit/block/Block.java b/src/main/java/org/bukkit/block/Block.java
index e405c279f6135c94c775a856ab88fd3cace6bd5c..0fb9340f224bcc0a328f4e8361426705281fad84 100644
--- a/src/main/java/org/bukkit/block/Block.java
+++ b/src/main/java/org/bukkit/block/Block.java
@@ -745,4 +745,16 @@ public interface Block extends Metadatable, net.kyori.adventure.translation.Tran
     @NotNull
     float getDestroySpeed(@NotNull ItemStack itemStack, boolean considerEnchants);
     // Paper end
+
+    // Sapphire start
+    /**
+     * Returns a custom tag container of this block.
+     *
+     * @return custon NBT tags container
+     */
+    @NotNull
+    default io.sapphiremc.sapphire.api.nbt.NBTCompound getNBTCompound() {
+        return new io.sapphiremc.sapphire.api.nbt.NBTBlock(this).getData();
+    }
+    // Sapphire end
 }
diff --git a/src/main/java/org/bukkit/block/TileState.java b/src/main/java/org/bukkit/block/TileState.java
index 5c8517c5bcae10161952c104b6a4ff7c713bcdbd..12df0126e1437765d7352f93be81e66df1fdff5a 100644
--- a/src/main/java/org/bukkit/block/TileState.java
+++ b/src/main/java/org/bukkit/block/TileState.java
@@ -50,4 +50,26 @@ public interface TileState extends BlockState, PersistentDataHolder {
      */
     boolean isSnapshot();
     // Paper end
+
+    // Sapphire start
+    /**
+     * Returns NBT representation of this tile entity.
+     *
+     * @return vanilla NBT tags container
+     */
+    @NotNull
+    default io.sapphiremc.sapphire.api.nbt.NBTTileEntity getNBT() {
+        return new io.sapphiremc.sapphire.api.nbt.NBTTileEntity(this);
+    }
+
+    /**
+     * Returns a custom tag container of this tile entity.
+     *
+     * @return custom NBT tags container
+     */
+    @NotNull
+    default io.sapphiremc.sapphire.api.nbt.NBTCompound getNBTCompound() {
+        return getNBT().getPersistentDataContainer();
+    }
+    // Sapphire end
 }
diff --git a/src/main/java/org/bukkit/entity/Entity.java b/src/main/java/org/bukkit/entity/Entity.java
index 03b35d3ba8ba00c0fa0272450f19355244a014ea..402fde605b1d2005767008f9a3fbaedf9022f3dd 100644
--- a/src/main/java/org/bukkit/entity/Entity.java
+++ b/src/main/java/org/bukkit/entity/Entity.java
@@ -897,4 +897,26 @@ public interface Entity extends Metadatable, CommandSender, Nameable, Persistent
      */
     boolean isInPowderedSnow();
     // Paper end
+
+    // Sapphire start
+    /**
+     * Returns NBT representation of this entity.
+     *
+     * @return vanilla NBT tags container
+     */
+    @NotNull
+    default io.sapphiremc.sapphire.api.nbt.NBTEntity getNBT() {
+        return new io.sapphiremc.sapphire.api.nbt.NBTEntity(this);
+    }
+
+    /**
+     * Returns a custom tag container of this entity.
+     *
+     * @return custon NBT tags container
+     */
+    @NotNull
+    default io.sapphiremc.sapphire.api.nbt.NBTCompound getNBTCompound() {
+        return getNBT().getPersistentDataContainer();
+    }
+    // Sapphire end
 }
diff --git a/src/main/java/org/bukkit/inventory/ItemStack.java b/src/main/java/org/bukkit/inventory/ItemStack.java
index b8a344fd900dcbd4b28085a54b85b16c742e9c6f..2f62877b1bbd2a56faf36f492e6d98ac386a95f2 100644
--- a/src/main/java/org/bukkit/inventory/ItemStack.java
+++ b/src/main/java/org/bukkit/inventory/ItemStack.java
@@ -978,4 +978,42 @@ public class ItemStack implements Cloneable, ConfigurationSerializable, net.kyor
         return Bukkit.getUnsafe().isValidRepairItemStack(toBeRepaired, this);
     }
     // Paper end
+
+    // Sapphire start
+    /**
+     * Returns NBT representation of this item. The ItemStack will be cloned!
+     *
+     * @return item's NBT tag container
+     */
+    @NotNull
+    public io.sapphiremc.sapphire.api.nbt.NBTItem getNBT() {
+        return new io.sapphiremc.sapphire.api.nbt.NBTItem(this);
+    }
+
+    /**
+     * Returns NBT representation of this item. If directApply is true,
+     * all changes will be mapped to the original item. Changes to the NBTItem
+     * will overwrite changes done to the original item in that case.
+     *
+     * @param directApply if true, changes to NBTItem will affect this ItemStack
+     * @return item's NBT tags container
+     */
+    @NotNull
+    public io.sapphiremc.sapphire.api.nbt.NBTItem getNBT(boolean directApply) {
+        return new io.sapphiremc.sapphire.api.nbt.NBTItem(this, directApply);
+    }
+
+    /**
+     * Applies NBT data from the provided NBT item.
+     *
+     * @param nbtItem ItemStack's NBT container
+     */
+    public void setNBT(@NotNull io.sapphiremc.sapphire.api.nbt.NBTItem nbtItem) {
+        ItemStack item = nbtItem.getItem();
+        setType(item.getType());
+        setAmount(item.getAmount());
+        setData(item.getData());
+        setItemMeta(item.getItemMeta());
+    }
+    // Sapphire end
 }
diff --git a/src/test/java/org/bukkit/AnnotationTest.java b/src/test/java/org/bukkit/AnnotationTest.java
index bbe81f7a420f913ffdcad913a3c43ff41ead41f5..9efd19904816658bad892393a9a07aa2c399d293 100644
--- a/src/test/java/org/bukkit/AnnotationTest.java
+++ b/src/test/java/org/bukkit/AnnotationTest.java
@@ -57,8 +57,45 @@ public class AnnotationTest {
         "co/aikar/timings/TimingHistory$2$1$2",
         "co/aikar/timings/TimingHistory$3",
         "co/aikar/timings/TimingHistory$4",
-        "co/aikar/timings/TimingHistoryEntry$1"
+        "co/aikar/timings/TimingHistoryEntry$1",
         // Paper end
+        // Sapphire start - exclude nbt api from tests
+        "io/sapphiremc/sapphire/api/nbt/NBTBlock",
+        "io/sapphiremc/sapphire/api/nbt/NBTChunk",
+        "io/sapphiremc/sapphire/api/nbt/NBTCompound",
+        "io/sapphiremc/sapphire/api/nbt/NBTCompoundList",
+        "io/sapphiremc/sapphire/api/nbt/NBTContainer",
+        "io/sapphiremc/sapphire/api/nbt/NBTDoubleList",
+        "io/sapphiremc/sapphire/api/nbt/NBTEntity",
+        "io/sapphiremc/sapphire/api/nbt/NBTException",
+        "io/sapphiremc/sapphire/api/nbt/NBTFile",
+        "io/sapphiremc/sapphire/api/nbt/NBTFloatList",
+        "io/sapphiremc/sapphire/api/nbt/NBTGameProfile",
+        "io/sapphiremc/sapphire/api/nbt/NBTIntegerList",
+        "io/sapphiremc/sapphire/api/nbt/NBTItem",
+        "io/sapphiremc/sapphire/api/nbt/NBTList",
+        "io/sapphiremc/sapphire/api/nbt/NBTList$1",
+        "io/sapphiremc/sapphire/api/nbt/NBTList$2",
+        "io/sapphiremc/sapphire/api/nbt/NBTListCompound",
+        "io/sapphiremc/sapphire/api/nbt/NBTLongList",
+        "io/sapphiremc/sapphire/api/nbt/NBTPersistentDataContainer",
+        "io/sapphiremc/sapphire/api/nbt/NBTReflectionUtil",
+        "io/sapphiremc/sapphire/api/nbt/NBTStringList",
+        "io/sapphiremc/sapphire/api/nbt/NBTTileEntity",
+        "io/sapphiremc/sapphire/api/nbt/NBTType",
+        "io/sapphiremc/sapphire/api/nbt/NBTIntArrayList",
+        "io/sapphiremc/sapphire/api/nbt/NBTUUIDList",
+        "io/sapphiremc/sapphire/api/nbt/utils/GsonWrapper",
+        "io/sapphiremc/sapphire/api/nbt/utils/MinecraftVersion",
+        "io/sapphiremc/sapphire/api/nbt/utils/ReflectionUtil",
+        "io/sapphiremc/sapphire/api/nbt/utils/UUIDUtil",
+        "io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ClassWrapper",
+        "io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/MojangToMapping",
+        "io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ObjectCreator",
+        "io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/PackageWrapper",
+        "io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ReflectionMethod",
+        "io/sapphiremc/sapphire/api/nbt/utils/nmsmappings/ReflectionMethod$Since"
+        // Sapphire end
     };
 
     @Test
